"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/filepond-plugin-image-preview";
exports.ids = ["vendor-chunks/filepond-plugin-image-preview"];
exports.modules = {

/***/ "(ssr)/./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.esm.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.esm.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * FilePondPluginImagePreview 4.6.12\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n// test if file is of type image and can be viewed in canvas\nconst isPreviewableImage = file => /^image/.test(file.type);\n\nconst vectorMultiply = (v, amount) => createVector(v.x * amount, v.y * amount);\n\nconst vectorAdd = (a, b) => createVector(a.x + b.x, a.y + b.y);\n\nconst vectorNormalize = v => {\n  const l = Math.sqrt(v.x * v.x + v.y * v.y);\n  if (l === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  return createVector(v.x / l, v.y / l);\n};\n\nconst vectorRotate = (v, radians, origin) => {\n  const cos = Math.cos(radians);\n  const sin = Math.sin(radians);\n  const t = createVector(v.x - origin.x, v.y - origin.y);\n  return createVector(\n    origin.x + cos * t.x - sin * t.y,\n    origin.y + sin * t.x + cos * t.y\n  );\n};\n\nconst createVector = (x = 0, y = 0) => ({ x, y });\n\nconst getMarkupValue = (value, size, scalar = 1, axis) => {\n  if (typeof value === 'string') {\n    return parseFloat(value) * scalar;\n  }\n  if (typeof value === 'number') {\n    return value * (axis ? size[axis] : Math.min(size.width, size.height));\n  }\n  return;\n};\n\nconst getMarkupStyles = (markup, size, scale) => {\n  const lineStyle = markup.borderStyle || markup.lineStyle || 'solid';\n  const fill = markup.backgroundColor || markup.fontColor || 'transparent';\n  const stroke = markup.borderColor || markup.lineColor || 'transparent';\n  const strokeWidth = getMarkupValue(\n    markup.borderWidth || markup.lineWidth,\n    size,\n    scale\n  );\n  const lineCap = markup.lineCap || 'round';\n  const lineJoin = markup.lineJoin || 'round';\n  const dashes =\n    typeof lineStyle === 'string'\n      ? ''\n      : lineStyle.map(v => getMarkupValue(v, size, scale)).join(',');\n  const opacity = markup.opacity || 1;\n  return {\n    'stroke-linecap': lineCap,\n    'stroke-linejoin': lineJoin,\n    'stroke-width': strokeWidth || 0,\n    'stroke-dasharray': dashes,\n    stroke,\n    fill,\n    opacity\n  };\n};\n\nconst isDefined = value => value != null;\n\nconst getMarkupRect = (rect, size, scalar = 1) => {\n  let left =\n    getMarkupValue(rect.x, size, scalar, 'width') ||\n    getMarkupValue(rect.left, size, scalar, 'width');\n  let top =\n    getMarkupValue(rect.y, size, scalar, 'height') ||\n    getMarkupValue(rect.top, size, scalar, 'height');\n  let width = getMarkupValue(rect.width, size, scalar, 'width');\n  let height = getMarkupValue(rect.height, size, scalar, 'height');\n  let right = getMarkupValue(rect.right, size, scalar, 'width');\n  let bottom = getMarkupValue(rect.bottom, size, scalar, 'height');\n\n  if (!isDefined(top)) {\n    if (isDefined(height) && isDefined(bottom)) {\n      top = size.height - height - bottom;\n    } else {\n      top = bottom;\n    }\n  }\n\n  if (!isDefined(left)) {\n    if (isDefined(width) && isDefined(right)) {\n      left = size.width - width - right;\n    } else {\n      left = right;\n    }\n  }\n\n  if (!isDefined(width)) {\n    if (isDefined(left) && isDefined(right)) {\n      width = size.width - left - right;\n    } else {\n      width = 0;\n    }\n  }\n\n  if (!isDefined(height)) {\n    if (isDefined(top) && isDefined(bottom)) {\n      height = size.height - top - bottom;\n    } else {\n      height = 0;\n    }\n  }\n\n  return {\n    x: left || 0,\n    y: top || 0,\n    width: width || 0,\n    height: height || 0\n  };\n};\n\nconst pointsToPathShape = points =>\n  points\n    .map((point, index) => `${index === 0 ? 'M' : 'L'} ${point.x} ${point.y}`)\n    .join(' ');\n\nconst setAttributes = (element, attr) =>\n  Object.keys(attr).forEach(key => element.setAttribute(key, attr[key]));\n\nconst ns = 'http://www.w3.org/2000/svg';\nconst svg = (tag, attr) => {\n  const element = document.createElementNS(ns, tag);\n  if (attr) {\n    setAttributes(element, attr);\n  }\n  return element;\n};\n\nconst updateRect = element =>\n  setAttributes(element, {\n    ...element.rect,\n    ...element.styles\n  });\n\nconst updateEllipse = element => {\n  const cx = element.rect.x + element.rect.width * 0.5;\n  const cy = element.rect.y + element.rect.height * 0.5;\n  const rx = element.rect.width * 0.5;\n  const ry = element.rect.height * 0.5;\n  return setAttributes(element, {\n    cx,\n    cy,\n    rx,\n    ry,\n    ...element.styles\n  });\n};\n\nconst IMAGE_FIT_STYLE = {\n  contain: 'xMidYMid meet',\n  cover: 'xMidYMid slice'\n};\n\nconst updateImage = (element, markup) => {\n  setAttributes(element, {\n    ...element.rect,\n    ...element.styles,\n    preserveAspectRatio: IMAGE_FIT_STYLE[markup.fit] || 'none'\n  });\n};\n\nconst TEXT_ANCHOR = {\n  left: 'start',\n  center: 'middle',\n  right: 'end'\n};\n\nconst updateText = (element, markup, size, scale) => {\n  const fontSize = getMarkupValue(markup.fontSize, size, scale);\n  const fontFamily = markup.fontFamily || 'sans-serif';\n  const fontWeight = markup.fontWeight || 'normal';\n  const textAlign = TEXT_ANCHOR[markup.textAlign] || 'start';\n\n  setAttributes(element, {\n    ...element.rect,\n    ...element.styles,\n    'stroke-width': 0,\n    'font-weight': fontWeight,\n    'font-size': fontSize,\n    'font-family': fontFamily,\n    'text-anchor': textAlign\n  });\n\n  // update text\n  if (element.text !== markup.text) {\n    element.text = markup.text;\n    element.textContent = markup.text.length ? markup.text : ' ';\n  }\n};\n\nconst updateLine = (element, markup, size, scale) => {\n  setAttributes(element, {\n    ...element.rect,\n    ...element.styles,\n    fill: 'none'\n  });\n\n  const line = element.childNodes[0];\n  const begin = element.childNodes[1];\n  const end = element.childNodes[2];\n\n  const origin = element.rect;\n\n  const target = {\n    x: element.rect.x + element.rect.width,\n    y: element.rect.y + element.rect.height\n  };\n\n  setAttributes(line, {\n    x1: origin.x,\n    y1: origin.y,\n    x2: target.x,\n    y2: target.y\n  });\n\n  if (!markup.lineDecoration) return;\n\n  begin.style.display = 'none';\n  end.style.display = 'none';\n\n  const v = vectorNormalize({\n    x: target.x - origin.x,\n    y: target.y - origin.y\n  });\n\n  const l = getMarkupValue(0.05, size, scale);\n\n  if (markup.lineDecoration.indexOf('arrow-begin') !== -1) {\n    const arrowBeginRotationPoint = vectorMultiply(v, l);\n    const arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);\n    const arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);\n    const arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);\n\n    setAttributes(begin, {\n      style: 'display:block;',\n      d: `M${arrowBeginA.x},${arrowBeginA.y} L${origin.x},${origin.y} L${\n        arrowBeginB.x\n      },${arrowBeginB.y}`\n    });\n  }\n\n  if (markup.lineDecoration.indexOf('arrow-end') !== -1) {\n    const arrowEndRotationPoint = vectorMultiply(v, -l);\n    const arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);\n    const arrowEndA = vectorRotate(target, 2, arrowEndCenter);\n    const arrowEndB = vectorRotate(target, -2, arrowEndCenter);\n\n    setAttributes(end, {\n      style: 'display:block;',\n      d: `M${arrowEndA.x},${arrowEndA.y} L${target.x},${target.y} L${\n        arrowEndB.x\n      },${arrowEndB.y}`\n    });\n  }\n};\n\nconst updatePath = (element, markup, size, scale) => {\n  setAttributes(element, {\n    ...element.styles,\n    fill: 'none',\n    d: pointsToPathShape(\n      markup.points.map(point => ({\n        x: getMarkupValue(point.x, size, scale, 'width'),\n        y: getMarkupValue(point.y, size, scale, 'height')\n      }))\n    )\n  });\n};\n\nconst createShape = node => markup => svg(node, { id: markup.id });\n\nconst createImage = markup => {\n  const shape = svg('image', {\n    id: markup.id,\n    'stroke-linecap': 'round',\n    'stroke-linejoin': 'round',\n    opacity: '0'\n  });\n  shape.onload = () => {\n    shape.setAttribute('opacity', markup.opacity || 1);\n  };\n  shape.setAttributeNS(\n    'http://www.w3.org/1999/xlink',\n    'xlink:href',\n    markup.src\n  );\n  return shape;\n};\n\nconst createLine = markup => {\n  const shape = svg('g', {\n    id: markup.id,\n    'stroke-linecap': 'round',\n    'stroke-linejoin': 'round'\n  });\n\n  const line = svg('line');\n  shape.appendChild(line);\n\n  const begin = svg('path');\n  shape.appendChild(begin);\n\n  const end = svg('path');\n  shape.appendChild(end);\n\n  return shape;\n};\n\nconst CREATE_TYPE_ROUTES = {\n  image: createImage,\n  rect: createShape('rect'),\n  ellipse: createShape('ellipse'),\n  text: createShape('text'),\n  path: createShape('path'),\n  line: createLine\n};\n\nconst UPDATE_TYPE_ROUTES = {\n  rect: updateRect,\n  ellipse: updateEllipse,\n  image: updateImage,\n  text: updateText,\n  path: updatePath,\n  line: updateLine\n};\n\nconst createMarkupByType = (type, markup) => CREATE_TYPE_ROUTES[type](markup);\n\nconst updateMarkupByType = (element, type, markup, size, scale) => {\n  if (type !== 'path') {\n    element.rect = getMarkupRect(markup, size, scale);\n  }\n  element.styles = getMarkupStyles(markup, size, scale);\n  UPDATE_TYPE_ROUTES[type](element, markup, size, scale);\n};\n\nconst MARKUP_RECT = [\n  'x',\n  'y',\n  'left',\n  'top',\n  'right',\n  'bottom',\n  'width',\n  'height'\n];\n\nconst toOptionalFraction = value =>\n  typeof value === 'string' && /%/.test(value)\n    ? parseFloat(value) / 100\n    : value;\n\n// adds default markup properties, clones markup\nconst prepareMarkup = markup => {\n  const [type, props] = markup;\n\n  const rect = props.points\n    ? {}\n    : MARKUP_RECT.reduce((prev, curr) => {\n        prev[curr] = toOptionalFraction(props[curr]);\n        return prev;\n      }, {});\n\n  return [\n    type,\n    {\n      zIndex: 0,\n      ...props,\n      ...rect\n    }\n  ];\n};\n\nconst sortMarkupByZIndex = (a, b) => {\n  if (a[1].zIndex > b[1].zIndex) {\n    return 1;\n  }\n  if (a[1].zIndex < b[1].zIndex) {\n    return -1;\n  }\n  return 0;\n};\n\nconst createMarkupView = _ =>\n  _.utils.createView({\n    name: 'image-preview-markup',\n    tag: 'svg',\n    ignoreRect: true,\n    mixins: {\n      apis: ['width', 'height', 'crop', 'markup', 'resize', 'dirty']\n    },\n    write: ({ root, props }) => {\n      if (!props.dirty) return;\n\n      const { crop, resize, markup } = props;\n\n      const viewWidth = props.width;\n      const viewHeight = props.height;\n\n      let cropWidth = crop.width;\n      let cropHeight = crop.height;\n\n      if (resize) {\n        const { size } = resize;\n\n        let outputWidth = size && size.width;\n        let outputHeight = size && size.height;\n        const outputFit = resize.mode;\n        const outputUpscale = resize.upscale;\n\n        if (outputWidth && !outputHeight) outputHeight = outputWidth;\n        if (outputHeight && !outputWidth) outputWidth = outputHeight;\n\n        const shouldUpscale =\n          cropWidth < outputWidth && cropHeight < outputHeight;\n\n        if (!shouldUpscale || (shouldUpscale && outputUpscale)) {\n          let scalarWidth = outputWidth / cropWidth;\n          let scalarHeight = outputHeight / cropHeight;\n\n          if (outputFit === 'force') {\n            cropWidth = outputWidth;\n            cropHeight = outputHeight;\n          } else {\n            let scalar;\n            if (outputFit === 'cover') {\n              scalar = Math.max(scalarWidth, scalarHeight);\n            } else if (outputFit === 'contain') {\n              scalar = Math.min(scalarWidth, scalarHeight);\n            }\n            cropWidth = cropWidth * scalar;\n            cropHeight = cropHeight * scalar;\n          }\n        }\n      }\n\n      const size = {\n        width: viewWidth,\n        height: viewHeight\n      };\n\n      root.element.setAttribute('width', size.width);\n      root.element.setAttribute('height', size.height);\n\n      const scale = Math.min(viewWidth / cropWidth, viewHeight / cropHeight);\n\n      // clear\n      root.element.innerHTML = '';\n\n      // get filter\n      const markupFilter = root.query('GET_IMAGE_PREVIEW_MARKUP_FILTER');\n\n      // draw new\n      markup\n        .filter(markupFilter)\n        .map(prepareMarkup)\n        .sort(sortMarkupByZIndex)\n        .forEach(markup => {\n          const [type, settings] = markup;\n\n          // create\n          const element = createMarkupByType(type, settings);\n\n          // update\n          updateMarkupByType(element, type, settings, size, scale);\n\n          // add\n          root.element.appendChild(element);\n        });\n    }\n  });\n\nconst createVector$1 = (x, y) => ({ x, y });\n\nconst vectorDot = (a, b) => a.x * b.x + a.y * b.y;\n\nconst vectorSubtract = (a, b) => createVector$1(a.x - b.x, a.y - b.y);\n\nconst vectorDistanceSquared = (a, b) =>\n  vectorDot(vectorSubtract(a, b), vectorSubtract(a, b));\n\nconst vectorDistance = (a, b) => Math.sqrt(vectorDistanceSquared(a, b));\n\nconst getOffsetPointOnEdge = (length, rotation) => {\n  const a = length;\n\n  const A = 1.5707963267948966;\n  const B = rotation;\n  const C = 1.5707963267948966 - rotation;\n\n  const sinA = Math.sin(A);\n  const sinB = Math.sin(B);\n  const sinC = Math.sin(C);\n  const cosC = Math.cos(C);\n  const ratio = a / sinA;\n  const b = ratio * sinB;\n  const c = ratio * sinC;\n\n  return createVector$1(cosC * b, cosC * c);\n};\n\nconst getRotatedRectSize = (rect, rotation) => {\n  const w = rect.width;\n  const h = rect.height;\n\n  const hor = getOffsetPointOnEdge(w, rotation);\n  const ver = getOffsetPointOnEdge(h, rotation);\n\n  const tl = createVector$1(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));\n\n  const tr = createVector$1(\n    rect.x + rect.width + Math.abs(ver.y),\n    rect.y + Math.abs(ver.x)\n  );\n\n  const bl = createVector$1(\n    rect.x - Math.abs(ver.y),\n    rect.y + rect.height - Math.abs(ver.x)\n  );\n\n  return {\n    width: vectorDistance(tl, tr),\n    height: vectorDistance(tl, bl)\n  };\n};\n\nconst calculateCanvasSize = (image, canvasAspectRatio, zoom = 1) => {\n  const imageAspectRatio = image.height / image.width;\n\n  // determine actual pixels on x and y axis\n  let canvasWidth = 1;\n  let canvasHeight = canvasAspectRatio;\n  let imgWidth = 1;\n  let imgHeight = imageAspectRatio;\n  if (imgHeight > canvasHeight) {\n    imgHeight = canvasHeight;\n    imgWidth = imgHeight / imageAspectRatio;\n  }\n\n  const scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);\n  const width = image.width / (zoom * scalar * imgWidth);\n  const height = width * canvasAspectRatio;\n\n  return {\n    width: width,\n    height: height\n  };\n};\n\nconst getImageRectZoomFactor = (imageRect, cropRect, rotation, center) => {\n  // calculate available space round image center position\n  const cx = center.x > 0.5 ? 1 - center.x : center.x;\n  const cy = center.y > 0.5 ? 1 - center.y : center.y;\n  const imageWidth = cx * 2 * imageRect.width;\n  const imageHeight = cy * 2 * imageRect.height;\n\n  // calculate rotated crop rectangle size\n  const rotatedCropSize = getRotatedRectSize(cropRect, rotation);\n\n  // calculate scalar required to fit image\n  return Math.max(\n    rotatedCropSize.width / imageWidth,\n    rotatedCropSize.height / imageHeight\n  );\n};\n\nconst getCenteredCropRect = (container, aspectRatio) => {\n  let width = container.width;\n  let height = width * aspectRatio;\n  if (height > container.height) {\n    height = container.height;\n    width = height / aspectRatio;\n  }\n  const x = (container.width - width) * 0.5;\n  const y = (container.height - height) * 0.5;\n\n  return {\n    x,\n    y,\n    width,\n    height\n  };\n};\n\nconst getCurrentCropSize = (imageSize, crop = {}) => {\n  let { zoom, rotation, center, aspectRatio } = crop;\n\n  if (!aspectRatio) aspectRatio = imageSize.height / imageSize.width;\n\n  const canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);\n\n  const canvasCenter = {\n    x: canvasSize.width * 0.5,\n    y: canvasSize.height * 0.5\n  };\n\n  const stage = {\n    x: 0,\n    y: 0,\n    width: canvasSize.width,\n    height: canvasSize.height,\n    center: canvasCenter\n  };\n\n  const shouldLimit = typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n  const stageZoomFactor = getImageRectZoomFactor(\n    imageSize,\n    getCenteredCropRect(stage, aspectRatio),\n    rotation,\n    shouldLimit ? center : { x: 0.5, y: 0.5 }\n  );\n\n  const scale = zoom * stageZoomFactor;\n\n  // start drawing\n  return {\n    widthFloat: canvasSize.width / scale,\n    heightFloat: canvasSize.height / scale,\n    width: Math.round(canvasSize.width / scale),\n    height: Math.round(canvasSize.height / scale)\n  };\n};\n\nconst IMAGE_SCALE_SPRING_PROPS = {\n  type: 'spring',\n  stiffness: 0.5,\n  damping: 0.45,\n  mass: 10\n};\n\n// does horizontal and vertical flipping\nconst createBitmapView = _ =>\n  _.utils.createView({\n    name: 'image-bitmap',\n    ignoreRect: true,\n    mixins: { styles: ['scaleX', 'scaleY'] },\n    create: ({ root, props }) => {\n      root.appendChild(props.image);\n    }\n  });\n\n// shifts and rotates image\nconst createImageCanvasWrapper = _ =>\n  _.utils.createView({\n    name: 'image-canvas-wrapper',\n    tag: 'div',\n    ignoreRect: true,\n    mixins: {\n      apis: ['crop', 'width', 'height'],\n      styles: [\n        'originX',\n        'originY',\n        'translateX',\n        'translateY',\n        'scaleX',\n        'scaleY',\n        'rotateZ'\n      ],\n      animations: {\n        originX: IMAGE_SCALE_SPRING_PROPS,\n        originY: IMAGE_SCALE_SPRING_PROPS,\n        scaleX: IMAGE_SCALE_SPRING_PROPS,\n        scaleY: IMAGE_SCALE_SPRING_PROPS,\n        translateX: IMAGE_SCALE_SPRING_PROPS,\n        translateY: IMAGE_SCALE_SPRING_PROPS,\n        rotateZ: IMAGE_SCALE_SPRING_PROPS\n      }\n    },\n    create: ({ root, props }) => {\n      props.width = props.image.width;\n      props.height = props.image.height;\n      root.ref.bitmap = root.appendChildView(\n        root.createChildView(createBitmapView(_), { image: props.image })\n      );\n    },\n    write: ({ root, props }) => {\n      const { flip } = props.crop;\n      const { bitmap } = root.ref;\n      bitmap.scaleX = flip.horizontal ? -1 : 1;\n      bitmap.scaleY = flip.vertical ? -1 : 1;\n    }\n  });\n\n// clips canvas to correct aspect ratio\nconst createClipView = _ =>\n  _.utils.createView({\n    name: 'image-clip',\n    tag: 'div',\n    ignoreRect: true,\n    mixins: {\n      apis: [\n        'crop',\n        'markup',\n        'resize',\n        'width',\n        'height',\n        'dirty',\n        'background'\n      ],\n      styles: ['width', 'height', 'opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 250 }\n      }\n    },\n    didWriteView: function({ root, props }) {\n      if (!props.background) return;\n      root.element.style.backgroundColor = props.background;\n    },\n    create: ({ root, props }) => {\n      root.ref.image = root.appendChildView(\n        root.createChildView(\n          createImageCanvasWrapper(_),\n          Object.assign({}, props)\n        )\n      );\n\n      root.ref.createMarkup = () => {\n        if (root.ref.markup) return;\n        root.ref.markup = root.appendChildView(\n          root.createChildView(createMarkupView(_), Object.assign({}, props))\n        );\n      };\n\n      root.ref.destroyMarkup = () => {\n        if (!root.ref.markup) return;\n        root.removeChildView(root.ref.markup);\n        root.ref.markup = null;\n      };\n\n      // set up transparency grid\n      const transparencyIndicator = root.query(\n        'GET_IMAGE_PREVIEW_TRANSPARENCY_INDICATOR'\n      );\n      if (transparencyIndicator === null) return;\n\n      // grid pattern\n      if (transparencyIndicator === 'grid') {\n        root.element.dataset.transparencyIndicator = transparencyIndicator;\n      }\n      // basic color\n      else {\n        root.element.dataset.transparencyIndicator = 'color';\n      }\n    },\n    write: ({ root, props, shouldOptimize }) => {\n      const { crop, markup, resize, dirty, width, height } = props;\n\n      root.ref.image.crop = crop;\n\n      const stage = {\n        x: 0,\n        y: 0,\n        width,\n        height,\n        center: {\n          x: width * 0.5,\n          y: height * 0.5\n        }\n      };\n\n      const image = {\n        width: root.ref.image.width,\n        height: root.ref.image.height\n      };\n\n      const origin = {\n        x: crop.center.x * image.width,\n        y: crop.center.y * image.height\n      };\n\n      const translation = {\n        x: stage.center.x - image.width * crop.center.x,\n        y: stage.center.y - image.height * crop.center.y\n      };\n\n      const rotation = Math.PI * 2 + (crop.rotation % (Math.PI * 2));\n\n      const cropAspectRatio = crop.aspectRatio || image.height / image.width;\n\n      const shouldLimit =\n        typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n      const stageZoomFactor = getImageRectZoomFactor(\n        image,\n        getCenteredCropRect(stage, cropAspectRatio),\n        rotation,\n        shouldLimit ? crop.center : { x: 0.5, y: 0.5 }\n      );\n\n      const scale = crop.zoom * stageZoomFactor;\n\n      // update markup view\n      if (markup && markup.length) {\n        root.ref.createMarkup();\n        root.ref.markup.width = width;\n        root.ref.markup.height = height;\n        root.ref.markup.resize = resize;\n        root.ref.markup.dirty = dirty;\n        root.ref.markup.markup = markup;\n        root.ref.markup.crop = getCurrentCropSize(image, crop);\n      } else if (root.ref.markup) {\n        root.ref.destroyMarkup();\n      }\n\n      // update image view\n      const imageView = root.ref.image;\n\n      // don't update clip layout\n      if (shouldOptimize) {\n        imageView.originX = null;\n        imageView.originY = null;\n        imageView.translateX = null;\n        imageView.translateY = null;\n        imageView.rotateZ = null;\n        imageView.scaleX = null;\n        imageView.scaleY = null;\n        return;\n      }\n\n      imageView.originX = origin.x;\n      imageView.originY = origin.y;\n      imageView.translateX = translation.x;\n      imageView.translateY = translation.y;\n      imageView.rotateZ = rotation;\n      imageView.scaleX = scale;\n      imageView.scaleY = scale;\n    }\n  });\n\nconst createImageView = _ =>\n  _.utils.createView({\n    name: 'image-preview',\n    tag: 'div',\n    ignoreRect: true,\n    mixins: {\n      apis: ['image', 'crop', 'markup', 'resize', 'dirty', 'background'],\n      styles: ['translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: IMAGE_SCALE_SPRING_PROPS,\n        scaleY: IMAGE_SCALE_SPRING_PROPS,\n        translateY: IMAGE_SCALE_SPRING_PROPS,\n        opacity: { type: 'tween', duration: 400 }\n      }\n    },\n    create: ({ root, props }) => {\n      root.ref.clip = root.appendChildView(\n        root.createChildView(createClipView(_), {\n          id: props.id,\n          image: props.image,\n          crop: props.crop,\n          markup: props.markup,\n          resize: props.resize,\n          dirty: props.dirty,\n          background: props.background\n        })\n      );\n    },\n    write: ({ root, props, shouldOptimize }) => {\n      const { clip } = root.ref;\n\n      const { image, crop, markup, resize, dirty } = props;\n\n      clip.crop = crop;\n      clip.markup = markup;\n      clip.resize = resize;\n      clip.dirty = dirty;\n\n      // don't update clip layout\n      clip.opacity = shouldOptimize ? 0 : 1;\n\n      // don't re-render if optimizing or hidden (width will be zero resulting in weird animations)\n      if (shouldOptimize || root.rect.element.hidden) return;\n\n      // calculate scaled preview image size\n      const imageAspectRatio = image.height / image.width;\n      let aspectRatio = crop.aspectRatio || imageAspectRatio;\n\n      // calculate container size\n      const containerWidth = root.rect.inner.width;\n      const containerHeight = root.rect.inner.height;\n\n      let fixedPreviewHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n      const minPreviewHeight = root.query('GET_IMAGE_PREVIEW_MIN_HEIGHT');\n      const maxPreviewHeight = root.query('GET_IMAGE_PREVIEW_MAX_HEIGHT');\n\n      const panelAspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n      const allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n\n      if (panelAspectRatio && !allowMultiple) {\n        fixedPreviewHeight = containerWidth * panelAspectRatio;\n        aspectRatio = panelAspectRatio;\n      }\n\n      // determine clip width and height\n      let clipHeight =\n        fixedPreviewHeight !== null\n          ? fixedPreviewHeight\n          : Math.max(\n              minPreviewHeight,\n              Math.min(containerWidth * aspectRatio, maxPreviewHeight)\n            );\n\n      let clipWidth = clipHeight / aspectRatio;\n      if (clipWidth > containerWidth) {\n        clipWidth = containerWidth;\n        clipHeight = clipWidth * aspectRatio;\n      }\n\n      if (clipHeight > containerHeight) {\n        clipHeight = containerHeight;\n        clipWidth = containerHeight / aspectRatio;\n      }\n\n      clip.width = clipWidth;\n      clip.height = clipHeight;\n    }\n  });\n\nlet SVG_MASK = `<svg width=\"500\" height=\"200\" viewBox=\"0 0 500 200\" preserveAspectRatio=\"none\">\n    <defs>\n        <radialGradient id=\"gradient-__UID__\" cx=\".5\" cy=\"1.25\" r=\"1.15\">\n            <stop offset='50%' stop-color='#000000'/>\n            <stop offset='56%' stop-color='#0a0a0a'/>\n            <stop offset='63%' stop-color='#262626'/>\n            <stop offset='69%' stop-color='#4f4f4f'/>\n            <stop offset='75%' stop-color='#808080'/>\n            <stop offset='81%' stop-color='#b1b1b1'/>\n            <stop offset='88%' stop-color='#dadada'/>\n            <stop offset='94%' stop-color='#f6f6f6'/>\n            <stop offset='100%' stop-color='#ffffff'/>\n        </radialGradient>\n        <mask id=\"mask-__UID__\">\n            <rect x=\"0\" y=\"0\" width=\"500\" height=\"200\" fill=\"url(#gradient-__UID__)\"></rect>\n        </mask>\n    </defs>\n    <rect x=\"0\" width=\"500\" height=\"200\" fill=\"currentColor\" mask=\"url(#mask-__UID__)\"></rect>\n</svg>`;\n\nlet SVGMaskUniqueId = 0;\n\nconst createImageOverlayView = fpAPI =>\n  fpAPI.utils.createView({\n    name: 'image-preview-overlay',\n    tag: 'div',\n    ignoreRect: true,\n    create: ({ root, props }) => {\n      let mask = SVG_MASK;\n      if (document.querySelector('base')) {\n        const url = new URL(\n          window.location.href.replace(window.location.hash, '')\n        ).href;\n        mask = mask.replace(/url\\(\\#/g, 'url(' + url + '#');\n      }\n\n      SVGMaskUniqueId++;\n      root.element.classList.add(\n        `filepond--image-preview-overlay-${props.status}`\n      );\n      root.element.innerHTML = mask.replace(/__UID__/g, SVGMaskUniqueId);\n    },\n    mixins: {\n      styles: ['opacity'],\n      animations: {\n        opacity: { type: 'spring', mass: 25 }\n      }\n    }\n  });\n\n/**\n * Bitmap Worker\n */\nconst BitmapWorker = function() {\n  self.onmessage = e => {\n    createImageBitmap(e.data.message.file).then(bitmap => {\n      self.postMessage({ id: e.data.id, message: bitmap }, [bitmap]);\n    });\n  };\n};\n\n/**\n * ColorMatrix Worker\n */\nconst ColorMatrixWorker = function() {\n  self.onmessage = e => {\n    const imageData = e.data.message.imageData;\n    const matrix = e.data.message.colorMatrix;\n\n    const data = imageData.data;\n    const l = data.length;\n\n    const m11 = matrix[0];\n    const m12 = matrix[1];\n    const m13 = matrix[2];\n    const m14 = matrix[3];\n    const m15 = matrix[4];\n\n    const m21 = matrix[5];\n    const m22 = matrix[6];\n    const m23 = matrix[7];\n    const m24 = matrix[8];\n    const m25 = matrix[9];\n\n    const m31 = matrix[10];\n    const m32 = matrix[11];\n    const m33 = matrix[12];\n    const m34 = matrix[13];\n    const m35 = matrix[14];\n\n    const m41 = matrix[15];\n    const m42 = matrix[16];\n    const m43 = matrix[17];\n    const m44 = matrix[18];\n    const m45 = matrix[19];\n\n    let index = 0,\n      r = 0.0,\n      g = 0.0,\n      b = 0.0,\n      a = 0.0;\n\n    for (; index < l; index += 4) {\n      r = data[index] / 255;\n      g = data[index + 1] / 255;\n      b = data[index + 2] / 255;\n      a = data[index + 3] / 255;\n      data[index] = Math.max(\n        0,\n        Math.min((r * m11 + g * m12 + b * m13 + a * m14 + m15) * 255, 255)\n      );\n      data[index + 1] = Math.max(\n        0,\n        Math.min((r * m21 + g * m22 + b * m23 + a * m24 + m25) * 255, 255)\n      );\n      data[index + 2] = Math.max(\n        0,\n        Math.min((r * m31 + g * m32 + b * m33 + a * m34 + m35) * 255, 255)\n      );\n      data[index + 3] = Math.max(\n        0,\n        Math.min((r * m41 + g * m42 + b * m43 + a * m44 + m45) * 255, 255)\n      );\n    }\n\n    self.postMessage({ id: e.data.id, message: imageData }, [\n      imageData.data.buffer\n    ]);\n  };\n};\n\nconst getImageSize = (url, cb) => {\n  let image = new Image();\n  image.onload = () => {\n    const width = image.naturalWidth;\n    const height = image.naturalHeight;\n    image = null;\n    cb(width, height);\n  };\n  image.src = url;\n};\n\nconst transforms = {\n  1: () => [1, 0, 0, 1, 0, 0],\n  2: width => [-1, 0, 0, 1, width, 0],\n  3: (width, height) => [-1, 0, 0, -1, width, height],\n  4: (width, height) => [1, 0, 0, -1, 0, height],\n  5: () => [0, 1, 1, 0, 0, 0],\n  6: (width, height) => [0, 1, -1, 0, height, 0],\n  7: (width, height) => [0, -1, -1, 0, height, width],\n  8: width => [0, -1, 1, 0, 0, width]\n};\n\nconst fixImageOrientation = (ctx, width, height, orientation) => {\n  // no orientation supplied\n  if (orientation === -1) {\n    return;\n  }\n\n  ctx.transform.apply(ctx, transforms[orientation](width, height));\n};\n\n// draws the preview image to canvas\nconst createPreviewImage = (data, width, height, orientation) => {\n  // can't draw on half pixels\n  width = Math.round(width);\n  height = Math.round(height);\n\n  // draw image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n\n  // if is rotated incorrectly swap width and height\n  if (orientation >= 5 && orientation <= 8) {\n    [width, height] = [height, width];\n  }\n\n  // correct image orientation\n  fixImageOrientation(ctx, width, height, orientation);\n\n  // draw the image\n  ctx.drawImage(data, 0, 0, width, height);\n\n  return canvas;\n};\n\nconst isBitmap = file => /^image/.test(file.type) && !/svg/.test(file.type);\n\nconst MAX_WIDTH = 10;\nconst MAX_HEIGHT = 10;\n\nconst calculateAverageColor = image => {\n  const scalar = Math.min(MAX_WIDTH / image.width, MAX_HEIGHT / image.height);\n\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const width = (canvas.width = Math.ceil(image.width * scalar));\n  const height = (canvas.height = Math.ceil(image.height * scalar));\n  ctx.drawImage(image, 0, 0, width, height);\n  let data = null;\n  try {\n    data = ctx.getImageData(0, 0, width, height).data;\n  } catch (e) {\n    return null;\n  }\n  const l = data.length;\n\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let i = 0;\n\n  for (; i < l; i += 4) {\n    r += data[i] * data[i];\n    g += data[i + 1] * data[i + 1];\n    b += data[i + 2] * data[i + 2];\n  }\n\n  r = averageColor(r, l);\n  g = averageColor(g, l);\n  b = averageColor(b, l);\n\n  return { r, g, b };\n};\n\nconst averageColor = (c, l) => Math.floor(Math.sqrt(c / (l / 4)));\n\nconst cloneCanvas = (origin, target) => {\n  target = target || document.createElement('canvas');\n  target.width = origin.width;\n  target.height = origin.height;\n  const ctx = target.getContext('2d');\n  ctx.drawImage(origin, 0, 0);\n  return target;\n};\n\nconst cloneImageData = imageData => {\n  let id;\n  try {\n    id = new ImageData(imageData.width, imageData.height);\n  } catch (e) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    id = ctx.createImageData(imageData.width, imageData.height);\n  }\n  id.data.set(new Uint8ClampedArray(imageData.data));\n  return id;\n};\n\nconst loadImage = url =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'Anonymous';\n    img.onload = () => {\n      resolve(img);\n    };\n    img.onerror = e => {\n      reject(e);\n    };\n    img.src = url;\n  });\n\nconst createImageWrapperView = _ => {\n  // create overlay view\n  const OverlayView = createImageOverlayView(_);\n\n  const ImageView = createImageView(_);\n\n  const { createWorker } = _.utils;\n\n  const applyFilter = (root, filter, target) =>\n    new Promise(resolve => {\n      // will store image data for future filter updates\n      if (!root.ref.imageData) {\n        root.ref.imageData = target\n          .getContext('2d')\n          .getImageData(0, 0, target.width, target.height);\n      }\n\n      // get image data reference\n      const imageData = cloneImageData(root.ref.imageData);\n\n      if (!filter || filter.length !== 20) {\n        target.getContext('2d').putImageData(imageData, 0, 0);\n        return resolve();\n      }\n\n      const worker = createWorker(ColorMatrixWorker);\n      worker.post(\n        {\n          imageData,\n          colorMatrix: filter\n        },\n        response => {\n          // apply filtered colors\n          target.getContext('2d').putImageData(response, 0, 0);\n\n          // stop worker\n          worker.terminate();\n\n          // done!\n          resolve();\n        },\n        [imageData.data.buffer]\n      );\n    });\n\n  const removeImageView = (root, imageView) => {\n    root.removeChildView(imageView);\n    imageView.image.width = 1;\n    imageView.image.height = 1;\n    imageView._destroy();\n  };\n\n  // remove an image\n  const shiftImage = ({ root }) => {\n    const imageView = root.ref.images.shift();\n    imageView.opacity = 0;\n    imageView.translateY = -15;\n    root.ref.imageViewBin.push(imageView);\n    return imageView;\n  };\n\n  // add new image\n  const pushImage = ({ root, props, image }) => {\n    const id = props.id;\n    const item = root.query('GET_ITEM', { id });\n    if (!item) return;\n\n    const crop = item.getMetadata('crop') || {\n      center: {\n        x: 0.5,\n        y: 0.5\n      },\n      flip: {\n        horizontal: false,\n        vertical: false\n      },\n      zoom: 1,\n      rotation: 0,\n      aspectRatio: null\n    };\n\n    const background = root.query(\n      'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n    );\n\n    let markup;\n    let resize;\n    let dirty = false;\n    if (root.query('GET_IMAGE_PREVIEW_MARKUP_SHOW')) {\n      markup = item.getMetadata('markup') || [];\n      resize = item.getMetadata('resize');\n      dirty = true;\n    }\n\n    // append image presenter\n    const imageView = root.appendChildView(\n      root.createChildView(ImageView, {\n        id,\n        image,\n        crop,\n        resize,\n        markup,\n        dirty,\n        background,\n        opacity: 0,\n        scaleX: 1.15,\n        scaleY: 1.15,\n        translateY: 15\n      }),\n      root.childViews.length\n    );\n    root.ref.images.push(imageView);\n\n    // reveal the preview image\n    imageView.opacity = 1;\n    imageView.scaleX = 1;\n    imageView.scaleY = 1;\n    imageView.translateY = 0;\n\n    // the preview is now ready to be drawn\n    setTimeout(() => {\n      root.dispatch('DID_IMAGE_PREVIEW_SHOW', { id });\n    }, 250);\n  };\n\n  const updateImage = ({ root, props }) => {\n    const item = root.query('GET_ITEM', { id: props.id });\n    if (!item) return;\n    const imageView = root.ref.images[root.ref.images.length - 1];\n    imageView.crop = item.getMetadata('crop');\n    imageView.background = root.query(\n      'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n    );\n    if (root.query('GET_IMAGE_PREVIEW_MARKUP_SHOW')) {\n      imageView.dirty = true;\n      imageView.resize = item.getMetadata('resize');\n      imageView.markup = item.getMetadata('markup');\n    }\n  };\n\n  // replace image preview\n  const didUpdateItemMetadata = ({ root, props, action }) => {\n    // only filter and crop trigger redraw\n    if (!/crop|filter|markup|resize/.test(action.change.key)) return;\n\n    // no images to update, exit\n    if (!root.ref.images.length) return;\n\n    // no item found, exit\n    const item = root.query('GET_ITEM', { id: props.id });\n    if (!item) return;\n\n    // for now, update existing image when filtering\n    if (/filter/.test(action.change.key)) {\n      const imageView = root.ref.images[root.ref.images.length - 1];\n      applyFilter(root, action.change.value, imageView.image);\n      return;\n    }\n\n    if (/crop|markup|resize/.test(action.change.key)) {\n      const crop = item.getMetadata('crop');\n      const image = root.ref.images[root.ref.images.length - 1];\n\n      // if aspect ratio has changed, we need to create a new image\n      if (\n        crop &&\n        crop.aspectRatio &&\n        image.crop &&\n        image.crop.aspectRatio &&\n        Math.abs(crop.aspectRatio - image.crop.aspectRatio) > 0.00001\n      ) {\n        const imageView = shiftImage({ root });\n        pushImage({ root, props, image: cloneCanvas(imageView.image) });\n      }\n      // if not, we can update the current image\n      else {\n        updateImage({ root, props });\n      }\n    }\n  };\n\n  const canCreateImageBitmap = file => {\n    // Firefox versions before 58 will freeze when running createImageBitmap\n    // in a Web Worker so we detect those versions and return false for support\n    const userAgent = window.navigator.userAgent;\n    const isFirefox = userAgent.match(/Firefox\\/([0-9]+)\\./);\n    const firefoxVersion = isFirefox ? parseInt(isFirefox[1]) : null;\n    if (firefoxVersion !== null && firefoxVersion <= 58) return false;\n\n    return 'createImageBitmap' in window && isBitmap(file);\n  };\n\n  /**\n   * Write handler for when preview container has been created\n   */\n  const didCreatePreviewContainer = ({ root, props }) => {\n    const { id } = props;\n\n    // we need to get the file data to determine the eventual image size\n    const item = root.query('GET_ITEM', id);\n    if (!item) return;\n\n    // get url to file (we'll revoke it later on when done)\n    const fileURL = URL.createObjectURL(item.file);\n\n    // determine image size of this item\n    getImageSize(fileURL, (width, height) => {\n      // we can now scale the panel to the final size\n      root.dispatch('DID_IMAGE_PREVIEW_CALCULATE_SIZE', {\n        id,\n        width,\n        height\n      });\n    });\n  };\n\n  const drawPreview = ({ root, props }) => {\n    const { id } = props;\n\n    // we need to get the file data to determine the eventual image size\n    const item = root.query('GET_ITEM', id);\n    if (!item) return;\n\n    // get url to file (we'll revoke it later on when done)\n    const fileURL = URL.createObjectURL(item.file);\n\n    // fallback\n    const loadPreviewFallback = () => {\n      // let's scale the image in the main thread :(\n      loadImage(fileURL).then(previewImageLoaded);\n    };\n\n    // image is now ready\n    const previewImageLoaded = imageData => {\n      // the file url is no longer needed\n      URL.revokeObjectURL(fileURL);\n\n      // draw the scaled down version here and use that as source so bitmapdata can be closed\n      // orientation info\n      const exif = item.getMetadata('exif') || {};\n      const orientation = exif.orientation || -1;\n\n      // get width and height from action, and swap if orientation is incorrect\n      let { width, height } = imageData;\n\n      // if no width or height, just return early.\n      if (!width || !height) return;\n\n      if (orientation >= 5 && orientation <= 8) {\n        [width, height] = [height, width];\n      }\n\n      // scale canvas based on pixel density\n      // we multiply by .75 as that creates smaller but still clear images on screens with high res displays\n      const pixelDensityFactor = Math.max(1, window.devicePixelRatio * 0.75);\n\n      // we want as much pixels to work with as possible,\n      // this multiplies the minimum image resolution,\n      // so when zooming in it doesn't get too blurry\n      const zoomFactor = root.query('GET_IMAGE_PREVIEW_ZOOM_FACTOR');\n\n      // imaeg scale factor\n      const scaleFactor = zoomFactor * pixelDensityFactor;\n\n      // calculate scaled preview image size\n      const previewImageRatio = height / width;\n\n      // calculate image preview height and width\n      const previewContainerWidth = root.rect.element.width;\n      const previewContainerHeight = root.rect.element.height;\n\n      let imageWidth = previewContainerWidth;\n      let imageHeight = imageWidth * previewImageRatio;\n\n      if (previewImageRatio > 1) {\n        imageWidth = Math.min(width, previewContainerWidth * scaleFactor);\n        imageHeight = imageWidth * previewImageRatio;\n      } else {\n        imageHeight = Math.min(height, previewContainerHeight * scaleFactor);\n        imageWidth = imageHeight / previewImageRatio;\n      }\n\n      // transfer to image tag so no canvas memory wasted on iOS\n      const previewImage = createPreviewImage(\n        imageData,\n        imageWidth,\n        imageHeight,\n        orientation\n      );\n\n      // done\n      const done = () => {\n        // calculate average image color, disabled for now\n        const averageColor = root.query(\n          'GET_IMAGE_PREVIEW_CALCULATE_AVERAGE_IMAGE_COLOR'\n        )\n          ? calculateAverageColor(data)\n          : null;\n        item.setMetadata('color', averageColor, true);\n\n        // data has been transferred to canvas ( if was ImageBitmap )\n        if ('close' in imageData) {\n          imageData.close();\n        }\n\n        // show the overlay\n        root.ref.overlayShadow.opacity = 1;\n\n        // create the first image\n        pushImage({ root, props, image: previewImage });\n      };\n\n      // apply filter\n      const filter = item.getMetadata('filter');\n      if (filter) {\n        applyFilter(root, filter, previewImage).then(done);\n      } else {\n        done();\n      }\n    };\n\n    // if we support scaling using createImageBitmap we use a worker\n    if (canCreateImageBitmap(item.file)) {\n      // let's scale the image in a worker\n      const worker = createWorker(BitmapWorker);\n\n      worker.post(\n        {\n          file: item.file\n        },\n        imageBitmap => {\n          // destroy worker\n          worker.terminate();\n\n          // no bitmap returned, must be something wrong,\n          // try the oldschool way\n          if (!imageBitmap) {\n            loadPreviewFallback();\n            return;\n          }\n\n          // yay we got our bitmap, let's continue showing the preview\n          previewImageLoaded(imageBitmap);\n        }\n      );\n    } else {\n      // create fallback preview\n      loadPreviewFallback();\n    }\n  };\n\n  /**\n   * Write handler for when the preview image is ready to be animated\n   */\n  const didDrawPreview = ({ root }) => {\n    // get last added image\n    const image = root.ref.images[root.ref.images.length - 1];\n    image.translateY = 0;\n    image.scaleX = 1.0;\n    image.scaleY = 1.0;\n    image.opacity = 1;\n  };\n\n  /**\n   * Write handler for when the preview has been loaded\n   */\n  const restoreOverlay = ({ root }) => {\n    root.ref.overlayShadow.opacity = 1;\n    root.ref.overlayError.opacity = 0;\n    root.ref.overlaySuccess.opacity = 0;\n  };\n\n  const didThrowError = ({ root }) => {\n    root.ref.overlayShadow.opacity = 0.25;\n    root.ref.overlayError.opacity = 1;\n  };\n\n  const didCompleteProcessing = ({ root }) => {\n    root.ref.overlayShadow.opacity = 0.25;\n    root.ref.overlaySuccess.opacity = 1;\n  };\n\n  /**\n   * Constructor\n   */\n  const create = ({ root }) => {\n    // image view\n    root.ref.images = [];\n\n    // the preview image data (we need this to filter the image)\n    root.ref.imageData = null;\n\n    // image bin\n    root.ref.imageViewBin = [];\n\n    // image overlays\n    root.ref.overlayShadow = root.appendChildView(\n      root.createChildView(OverlayView, {\n        opacity: 0,\n        status: 'idle'\n      })\n    );\n\n    root.ref.overlaySuccess = root.appendChildView(\n      root.createChildView(OverlayView, {\n        opacity: 0,\n        status: 'success'\n      })\n    );\n\n    root.ref.overlayError = root.appendChildView(\n      root.createChildView(OverlayView, {\n        opacity: 0,\n        status: 'failure'\n      })\n    );\n  };\n\n  return _.utils.createView({\n    name: 'image-preview-wrapper',\n    create,\n    styles: ['height'],\n    apis: ['height'],\n    destroy: ({ root }) => {\n      // we resize the image so memory on iOS 12 is released more quickly (it seems)\n      root.ref.images.forEach(imageView => {\n        imageView.image.width = 1;\n        imageView.image.height = 1;\n      });\n    },\n    didWriteView: ({ root }) => {\n      root.ref.images.forEach(imageView => {\n        imageView.dirty = false;\n      });\n    },\n    write: _.utils.createRoute(\n      {\n        // image preview stated\n        DID_IMAGE_PREVIEW_DRAW: didDrawPreview,\n        DID_IMAGE_PREVIEW_CONTAINER_CREATE: didCreatePreviewContainer,\n        DID_FINISH_CALCULATE_PREVIEWSIZE: drawPreview,\n        DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata,\n\n        // file states\n        DID_THROW_ITEM_LOAD_ERROR: didThrowError,\n        DID_THROW_ITEM_PROCESSING_ERROR: didThrowError,\n        DID_THROW_ITEM_INVALID: didThrowError,\n        DID_COMPLETE_ITEM_PROCESSING: didCompleteProcessing,\n        DID_START_ITEM_PROCESSING: restoreOverlay,\n        DID_REVERT_ITEM_PROCESSING: restoreOverlay\n      },\n      ({ root }) => {\n        // views on death row\n        const viewsToRemove = root.ref.imageViewBin.filter(\n          imageView => imageView.opacity === 0\n        );\n\n        // views to retain\n        root.ref.imageViewBin = root.ref.imageViewBin.filter(\n          imageView => imageView.opacity > 0\n        );\n\n        // remove these views\n        viewsToRemove.forEach(imageView => removeImageView(root, imageView));\n        viewsToRemove.length = 0;\n      }\n    )\n  });\n};\n\n/**\n * Image Preview Plugin\n */\nconst plugin = fpAPI => {\n  const { addFilter, utils } = fpAPI;\n  const { Type, createRoute, isFile } = utils;\n\n  // imagePreviewView\n  const imagePreviewView = createImageWrapperView(fpAPI);\n\n  // called for each view that is created right after the 'create' method\n  addFilter('CREATE_VIEW', viewAPI => {\n    // get reference to created view\n    const { is, view, query } = viewAPI;\n\n    // only hook up to item view and only if is enabled for this cropper\n    if (!is('file') || !query('GET_ALLOW_IMAGE_PREVIEW')) return;\n\n    // create the image preview plugin, but only do so if the item is an image\n    const didLoadItem = ({ root, props }) => {\n      const { id } = props;\n      const item = query('GET_ITEM', id);\n\n      // item could theoretically have been removed in the mean time\n      if (!item || !isFile(item.file) || item.archived) return;\n\n      // get the file object\n      const file = item.file;\n\n      // exit if this is not an image\n      if (!isPreviewableImage(file)) return;\n\n      // test if is filtered\n      if (!query('GET_IMAGE_PREVIEW_FILTER_ITEM')(item)) return;\n\n      // exit if image size is too high and no createImageBitmap support\n      // this would simply bring the browser to its knees and that is not what we want\n      const supportsCreateImageBitmap = 'createImageBitmap' in (window || {});\n      const maxPreviewFileSize = query('GET_IMAGE_PREVIEW_MAX_FILE_SIZE');\n      if (\n        !supportsCreateImageBitmap &&\n        (maxPreviewFileSize && file.size > maxPreviewFileSize)\n      )\n        return;\n\n      // set preview view\n      root.ref.imagePreview = view.appendChildView(\n        view.createChildView(imagePreviewView, { id })\n      );\n\n      // update height if is fixed\n      const fixedPreviewHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n      if (fixedPreviewHeight) {\n        root.dispatch('DID_UPDATE_PANEL_HEIGHT', {\n          id: item.id,\n          height: fixedPreviewHeight\n        });\n      }\n\n      // now ready\n      const queue =\n        !supportsCreateImageBitmap &&\n        file.size > query('GET_IMAGE_PREVIEW_MAX_INSTANT_PREVIEW_FILE_SIZE');\n      root.dispatch('DID_IMAGE_PREVIEW_CONTAINER_CREATE', { id }, queue);\n    };\n\n    const rescaleItem = (root, props) => {\n      if (!root.ref.imagePreview) return;\n\n      let { id } = props;\n\n      // get item\n      const item = root.query('GET_ITEM', { id });\n      if (!item) return;\n\n      // if is fixed height or panel has aspect ratio, exit here, height has already been defined\n      const panelAspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n      const itemPanelAspectRatio = root.query('GET_ITEM_PANEL_ASPECT_RATIO');\n      const fixedHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n      if (panelAspectRatio || itemPanelAspectRatio || fixedHeight) return;\n\n      // no data!\n      let { imageWidth, imageHeight } = root.ref;\n      if (!imageWidth || !imageHeight) return;\n\n      // get height min and max\n      const minPreviewHeight = root.query('GET_IMAGE_PREVIEW_MIN_HEIGHT');\n      const maxPreviewHeight = root.query('GET_IMAGE_PREVIEW_MAX_HEIGHT');\n\n      // orientation info\n      const exif = item.getMetadata('exif') || {};\n      const orientation = exif.orientation || -1;\n\n      // get width and height from action, and swap of orientation is incorrect\n      if (orientation >= 5 && orientation <= 8)\n        [imageWidth, imageHeight] = [imageHeight, imageWidth];\n\n      // scale up width and height when we're dealing with an SVG\n      if (!isBitmap(item.file) || root.query('GET_IMAGE_PREVIEW_UPSCALE')) {\n        const scalar = 2048 / imageWidth;\n        imageWidth *= scalar;\n        imageHeight *= scalar;\n      }\n\n      // image aspect ratio\n      const imageAspectRatio = imageHeight / imageWidth;\n\n      // we need the item to get to the crop size\n      const previewAspectRatio =\n        (item.getMetadata('crop') || {}).aspectRatio || imageAspectRatio;\n\n      // preview height range\n      let previewHeightMax = Math.max(\n        minPreviewHeight,\n        Math.min(imageHeight, maxPreviewHeight)\n      );\n      const itemWidth = root.rect.element.width;\n      const previewHeight = Math.min(\n        itemWidth * previewAspectRatio,\n        previewHeightMax\n      );\n\n      // request update to panel height\n      root.dispatch('DID_UPDATE_PANEL_HEIGHT', {\n        id: item.id,\n        height: previewHeight\n      });\n    };\n\n    const didResizeView = ({ root }) => {\n      // actions in next write operation\n      root.ref.shouldRescale = true;\n    };\n\n    const didUpdateItemMetadata = ({ root, action }) => {\n      if (action.change.key !== 'crop') return;\n\n      // actions in next write operation\n      root.ref.shouldRescale = true;\n    };\n\n    const didCalculatePreviewSize = ({ root, action }) => {\n      // remember dimensions\n      root.ref.imageWidth = action.width;\n      root.ref.imageHeight = action.height;\n\n      // actions in next write operation\n      root.ref.shouldRescale = true;\n      root.ref.shouldDrawPreview = true;\n\n      // as image load could take a while and fire when draw loop is resting we need to give it a kick\n      root.dispatch('KICK');\n    };\n\n    // start writing\n    view.registerWriter(\n      createRoute(\n        {\n          DID_RESIZE_ROOT: didResizeView,\n          DID_STOP_RESIZE: didResizeView,\n          DID_LOAD_ITEM: didLoadItem,\n          DID_IMAGE_PREVIEW_CALCULATE_SIZE: didCalculatePreviewSize,\n          DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata\n        },\n        ({ root, props }) => {\n          // no preview view attached\n          if (!root.ref.imagePreview) return;\n\n          // don't do anything while hidden\n          if (root.rect.element.hidden) return;\n\n          // resize the item panel\n          if (root.ref.shouldRescale) {\n            rescaleItem(root, props);\n            root.ref.shouldRescale = false;\n          }\n\n          if (root.ref.shouldDrawPreview) {\n            // queue till next frame so we're sure the height has been applied this forces the draw image call inside the wrapper view to use the correct height\n            requestAnimationFrame(() => {\n              // this requestAnimationFrame nesting is horrible but it fixes an issue with 100hz displays on Chrome\n              // https://github.com/pqina/filepond-plugin-image-preview/issues/57\n              requestAnimationFrame(() => {\n                root.dispatch('DID_FINISH_CALCULATE_PREVIEWSIZE', {\n                  id: props.id\n                });\n              });\n            });\n\n            root.ref.shouldDrawPreview = false;\n          }\n        }\n      )\n    );\n  });\n\n  // expose plugin\n  return {\n    options: {\n      // Enable or disable image preview\n      allowImagePreview: [true, Type.BOOLEAN],\n\n      // filters file items to determine which are shown as preview\n      imagePreviewFilterItem: [() => true, Type.FUNCTION],\n\n      // Fixed preview height\n      imagePreviewHeight: [null, Type.INT],\n\n      // Min image height\n      imagePreviewMinHeight: [44, Type.INT],\n\n      // Max image height\n      imagePreviewMaxHeight: [256, Type.INT],\n\n      // Max size of preview file for when createImageBitmap is not supported\n      imagePreviewMaxFileSize: [null, Type.INT],\n\n      // The amount of extra pixels added to the image preview to allow comfortable zooming\n      imagePreviewZoomFactor: [2, Type.INT],\n\n      // Should we upscale small images to fit the max bounding box of the preview area\n      imagePreviewUpscale: [false, Type.BOOLEAN],\n\n      // Max size of preview file that we allow to try to instant preview if createImageBitmap is not supported, else image is queued for loading\n      imagePreviewMaxInstantPreviewFileSize: [1000000, Type.INT],\n\n      // Style of the transparancy indicator used behind images\n      imagePreviewTransparencyIndicator: [null, Type.STRING],\n\n      // Enables or disables reading average image color\n      imagePreviewCalculateAverageImageColor: [false, Type.BOOLEAN],\n\n      // Enables or disables the previewing of markup\n      imagePreviewMarkupShow: [true, Type.BOOLEAN],\n\n      // Allows filtering of markup to only show certain shapes\n      imagePreviewMarkupFilter: [() => true, Type.FUNCTION]\n    }\n  };\n};\n\n// fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\nconst isBrowser =\n  typeof window !== 'undefined' && typeof window.document !== 'undefined';\nif (isBrowser) {\n  document.dispatchEvent(\n    new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n  );\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE1BQU07O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QixFQUFFLFNBQVMsRUFBRSxRQUFRO0FBQzVFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCLGFBQWEsY0FBYyxHQUFHLGVBQWUsR0FBRyxTQUFTLEdBQUcsVUFBVTtBQUN0RTtBQUNBLE9BQU8sR0FBRyxjQUFjO0FBQ3hCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCLGFBQWEsWUFBWSxHQUFHLGFBQWEsR0FBRyxTQUFTLEdBQUcsVUFBVTtBQUNsRTtBQUNBLE9BQU8sR0FBRyxZQUFZO0FBQ3RCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsa0RBQWtELGVBQWU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsYUFBYTtBQUMzQjs7QUFFQSxjQUFjLHVCQUF1Qjs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEdBQUc7O0FBRUgsb0NBQW9DLE1BQU07O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsZUFBZTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7O0FBRUEsaUVBQWUsTUFBTSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE5JS0hJTFxcT25lRHJpdmVcXERlc2tcXGxlYXJuaW5nX21hbmFnZW1lbnRcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxmaWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlld1xcZGlzdFxcZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmRQbHVnaW5JbWFnZVByZXZpZXcgNC42LjEyXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8vIHRlc3QgaWYgZmlsZSBpcyBvZiB0eXBlIGltYWdlIGFuZCBjYW4gYmUgdmlld2VkIGluIGNhbnZhc1xuY29uc3QgaXNQcmV2aWV3YWJsZUltYWdlID0gZmlsZSA9PiAvXmltYWdlLy50ZXN0KGZpbGUudHlwZSk7XG5cbmNvbnN0IHZlY3Rvck11bHRpcGx5ID0gKHYsIGFtb3VudCkgPT4gY3JlYXRlVmVjdG9yKHYueCAqIGFtb3VudCwgdi55ICogYW1vdW50KTtcblxuY29uc3QgdmVjdG9yQWRkID0gKGEsIGIpID0+IGNyZWF0ZVZlY3RvcihhLnggKyBiLngsIGEueSArIGIueSk7XG5cbmNvbnN0IHZlY3Rvck5vcm1hbGl6ZSA9IHYgPT4ge1xuICBjb25zdCBsID0gTWF0aC5zcXJ0KHYueCAqIHYueCArIHYueSAqIHYueSk7XG4gIGlmIChsID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4gY3JlYXRlVmVjdG9yKHYueCAvIGwsIHYueSAvIGwpO1xufTtcblxuY29uc3QgdmVjdG9yUm90YXRlID0gKHYsIHJhZGlhbnMsIG9yaWdpbikgPT4ge1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgY29uc3Qgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gIGNvbnN0IHQgPSBjcmVhdGVWZWN0b3Iodi54IC0gb3JpZ2luLngsIHYueSAtIG9yaWdpbi55KTtcbiAgcmV0dXJuIGNyZWF0ZVZlY3RvcihcbiAgICBvcmlnaW4ueCArIGNvcyAqIHQueCAtIHNpbiAqIHQueSxcbiAgICBvcmlnaW4ueSArIHNpbiAqIHQueCArIGNvcyAqIHQueVxuICApO1xufTtcblxuY29uc3QgY3JlYXRlVmVjdG9yID0gKHggPSAwLCB5ID0gMCkgPT4gKHsgeCwgeSB9KTtcblxuY29uc3QgZ2V0TWFya3VwVmFsdWUgPSAodmFsdWUsIHNpemUsIHNjYWxhciA9IDEsIGF4aXMpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgKiBzY2FsYXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWUgKiAoYXhpcyA/IHNpemVbYXhpc10gOiBNYXRoLm1pbihzaXplLndpZHRoLCBzaXplLmhlaWdodCkpO1xuICB9XG4gIHJldHVybjtcbn07XG5cbmNvbnN0IGdldE1hcmt1cFN0eWxlcyA9IChtYXJrdXAsIHNpemUsIHNjYWxlKSA9PiB7XG4gIGNvbnN0IGxpbmVTdHlsZSA9IG1hcmt1cC5ib3JkZXJTdHlsZSB8fCBtYXJrdXAubGluZVN0eWxlIHx8ICdzb2xpZCc7XG4gIGNvbnN0IGZpbGwgPSBtYXJrdXAuYmFja2dyb3VuZENvbG9yIHx8IG1hcmt1cC5mb250Q29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgY29uc3Qgc3Ryb2tlID0gbWFya3VwLmJvcmRlckNvbG9yIHx8IG1hcmt1cC5saW5lQ29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgY29uc3Qgc3Ryb2tlV2lkdGggPSBnZXRNYXJrdXBWYWx1ZShcbiAgICBtYXJrdXAuYm9yZGVyV2lkdGggfHwgbWFya3VwLmxpbmVXaWR0aCxcbiAgICBzaXplLFxuICAgIHNjYWxlXG4gICk7XG4gIGNvbnN0IGxpbmVDYXAgPSBtYXJrdXAubGluZUNhcCB8fCAncm91bmQnO1xuICBjb25zdCBsaW5lSm9pbiA9IG1hcmt1cC5saW5lSm9pbiB8fCAncm91bmQnO1xuICBjb25zdCBkYXNoZXMgPVxuICAgIHR5cGVvZiBsaW5lU3R5bGUgPT09ICdzdHJpbmcnXG4gICAgICA/ICcnXG4gICAgICA6IGxpbmVTdHlsZS5tYXAodiA9PiBnZXRNYXJrdXBWYWx1ZSh2LCBzaXplLCBzY2FsZSkpLmpvaW4oJywnKTtcbiAgY29uc3Qgb3BhY2l0eSA9IG1hcmt1cC5vcGFjaXR5IHx8IDE7XG4gIHJldHVybiB7XG4gICAgJ3N0cm9rZS1saW5lY2FwJzogbGluZUNhcCxcbiAgICAnc3Ryb2tlLWxpbmVqb2luJzogbGluZUpvaW4sXG4gICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoIHx8IDAsXG4gICAgJ3N0cm9rZS1kYXNoYXJyYXknOiBkYXNoZXMsXG4gICAgc3Ryb2tlLFxuICAgIGZpbGwsXG4gICAgb3BhY2l0eVxuICB9O1xufTtcblxuY29uc3QgaXNEZWZpbmVkID0gdmFsdWUgPT4gdmFsdWUgIT0gbnVsbDtcblxuY29uc3QgZ2V0TWFya3VwUmVjdCA9IChyZWN0LCBzaXplLCBzY2FsYXIgPSAxKSA9PiB7XG4gIGxldCBsZWZ0ID1cbiAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LngsIHNpemUsIHNjYWxhciwgJ3dpZHRoJykgfHxcbiAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LmxlZnQsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gIGxldCB0b3AgPVxuICAgIGdldE1hcmt1cFZhbHVlKHJlY3QueSwgc2l6ZSwgc2NhbGFyLCAnaGVpZ2h0JykgfHxcbiAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LnRvcCwgc2l6ZSwgc2NhbGFyLCAnaGVpZ2h0Jyk7XG4gIGxldCB3aWR0aCA9IGdldE1hcmt1cFZhbHVlKHJlY3Qud2lkdGgsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gIGxldCBoZWlnaHQgPSBnZXRNYXJrdXBWYWx1ZShyZWN0LmhlaWdodCwgc2l6ZSwgc2NhbGFyLCAnaGVpZ2h0Jyk7XG4gIGxldCByaWdodCA9IGdldE1hcmt1cFZhbHVlKHJlY3QucmlnaHQsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gIGxldCBib3R0b20gPSBnZXRNYXJrdXBWYWx1ZShyZWN0LmJvdHRvbSwgc2l6ZSwgc2NhbGFyLCAnaGVpZ2h0Jyk7XG5cbiAgaWYgKCFpc0RlZmluZWQodG9wKSkge1xuICAgIGlmIChpc0RlZmluZWQoaGVpZ2h0KSAmJiBpc0RlZmluZWQoYm90dG9tKSkge1xuICAgICAgdG9wID0gc2l6ZS5oZWlnaHQgLSBoZWlnaHQgLSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IGJvdHRvbTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzRGVmaW5lZChsZWZ0KSkge1xuICAgIGlmIChpc0RlZmluZWQod2lkdGgpICYmIGlzRGVmaW5lZChyaWdodCkpIHtcbiAgICAgIGxlZnQgPSBzaXplLndpZHRoIC0gd2lkdGggLSByaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgIGlmIChpc0RlZmluZWQobGVmdCkgJiYgaXNEZWZpbmVkKHJpZ2h0KSkge1xuICAgICAgd2lkdGggPSBzaXplLndpZHRoIC0gbGVmdCAtIHJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0RlZmluZWQoaGVpZ2h0KSkge1xuICAgIGlmIChpc0RlZmluZWQodG9wKSAmJiBpc0RlZmluZWQoYm90dG9tKSkge1xuICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQgLSB0b3AgLSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBsZWZ0IHx8IDAsXG4gICAgeTogdG9wIHx8IDAsXG4gICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgaGVpZ2h0OiBoZWlnaHQgfHwgMFxuICB9O1xufTtcblxuY29uc3QgcG9pbnRzVG9QYXRoU2hhcGUgPSBwb2ludHMgPT5cbiAgcG9pbnRzXG4gICAgLm1hcCgocG9pbnQsIGluZGV4KSA9PiBgJHtpbmRleCA9PT0gMCA/ICdNJyA6ICdMJ30gJHtwb2ludC54fSAke3BvaW50Lnl9YClcbiAgICAuam9pbignICcpO1xuXG5jb25zdCBzZXRBdHRyaWJ1dGVzID0gKGVsZW1lbnQsIGF0dHIpID0+XG4gIE9iamVjdC5rZXlzKGF0dHIpLmZvckVhY2goa2V5ID0+IGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cltrZXldKSk7XG5cbmNvbnN0IG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IHN2ZyA9ICh0YWcsIGF0dHIpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKTtcbiAgaWYgKGF0dHIpIHtcbiAgICBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHIpO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuY29uc3QgdXBkYXRlUmVjdCA9IGVsZW1lbnQgPT5cbiAgc2V0QXR0cmlidXRlcyhlbGVtZW50LCB7XG4gICAgLi4uZWxlbWVudC5yZWN0LFxuICAgIC4uLmVsZW1lbnQuc3R5bGVzXG4gIH0pO1xuXG5jb25zdCB1cGRhdGVFbGxpcHNlID0gZWxlbWVudCA9PiB7XG4gIGNvbnN0IGN4ID0gZWxlbWVudC5yZWN0LnggKyBlbGVtZW50LnJlY3Qud2lkdGggKiAwLjU7XG4gIGNvbnN0IGN5ID0gZWxlbWVudC5yZWN0LnkgKyBlbGVtZW50LnJlY3QuaGVpZ2h0ICogMC41O1xuICBjb25zdCByeCA9IGVsZW1lbnQucmVjdC53aWR0aCAqIDAuNTtcbiAgY29uc3QgcnkgPSBlbGVtZW50LnJlY3QuaGVpZ2h0ICogMC41O1xuICByZXR1cm4gc2V0QXR0cmlidXRlcyhlbGVtZW50LCB7XG4gICAgY3gsXG4gICAgY3ksXG4gICAgcngsXG4gICAgcnksXG4gICAgLi4uZWxlbWVudC5zdHlsZXNcbiAgfSk7XG59O1xuXG5jb25zdCBJTUFHRV9GSVRfU1RZTEUgPSB7XG4gIGNvbnRhaW46ICd4TWlkWU1pZCBtZWV0JyxcbiAgY292ZXI6ICd4TWlkWU1pZCBzbGljZSdcbn07XG5cbmNvbnN0IHVwZGF0ZUltYWdlID0gKGVsZW1lbnQsIG1hcmt1cCkgPT4ge1xuICBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIHtcbiAgICAuLi5lbGVtZW50LnJlY3QsXG4gICAgLi4uZWxlbWVudC5zdHlsZXMsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogSU1BR0VfRklUX1NUWUxFW21hcmt1cC5maXRdIHx8ICdub25lJ1xuICB9KTtcbn07XG5cbmNvbnN0IFRFWFRfQU5DSE9SID0ge1xuICBsZWZ0OiAnc3RhcnQnLFxuICBjZW50ZXI6ICdtaWRkbGUnLFxuICByaWdodDogJ2VuZCdcbn07XG5cbmNvbnN0IHVwZGF0ZVRleHQgPSAoZWxlbWVudCwgbWFya3VwLCBzaXplLCBzY2FsZSkgPT4ge1xuICBjb25zdCBmb250U2l6ZSA9IGdldE1hcmt1cFZhbHVlKG1hcmt1cC5mb250U2l6ZSwgc2l6ZSwgc2NhbGUpO1xuICBjb25zdCBmb250RmFtaWx5ID0gbWFya3VwLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnO1xuICBjb25zdCBmb250V2VpZ2h0ID0gbWFya3VwLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCc7XG4gIGNvbnN0IHRleHRBbGlnbiA9IFRFWFRfQU5DSE9SW21hcmt1cC50ZXh0QWxpZ25dIHx8ICdzdGFydCc7XG5cbiAgc2V0QXR0cmlidXRlcyhlbGVtZW50LCB7XG4gICAgLi4uZWxlbWVudC5yZWN0LFxuICAgIC4uLmVsZW1lbnQuc3R5bGVzLFxuICAgICdzdHJva2Utd2lkdGgnOiAwLFxuICAgICdmb250LXdlaWdodCc6IGZvbnRXZWlnaHQsXG4gICAgJ2ZvbnQtc2l6ZSc6IGZvbnRTaXplLFxuICAgICdmb250LWZhbWlseSc6IGZvbnRGYW1pbHksXG4gICAgJ3RleHQtYW5jaG9yJzogdGV4dEFsaWduXG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSB0ZXh0XG4gIGlmIChlbGVtZW50LnRleHQgIT09IG1hcmt1cC50ZXh0KSB7XG4gICAgZWxlbWVudC50ZXh0ID0gbWFya3VwLnRleHQ7XG4gICAgZWxlbWVudC50ZXh0Q29udGVudCA9IG1hcmt1cC50ZXh0Lmxlbmd0aCA/IG1hcmt1cC50ZXh0IDogJyAnO1xuICB9XG59O1xuXG5jb25zdCB1cGRhdGVMaW5lID0gKGVsZW1lbnQsIG1hcmt1cCwgc2l6ZSwgc2NhbGUpID0+IHtcbiAgc2V0QXR0cmlidXRlcyhlbGVtZW50LCB7XG4gICAgLi4uZWxlbWVudC5yZWN0LFxuICAgIC4uLmVsZW1lbnQuc3R5bGVzLFxuICAgIGZpbGw6ICdub25lJ1xuICB9KTtcblxuICBjb25zdCBsaW5lID0gZWxlbWVudC5jaGlsZE5vZGVzWzBdO1xuICBjb25zdCBiZWdpbiA9IGVsZW1lbnQuY2hpbGROb2Rlc1sxXTtcbiAgY29uc3QgZW5kID0gZWxlbWVudC5jaGlsZE5vZGVzWzJdO1xuXG4gIGNvbnN0IG9yaWdpbiA9IGVsZW1lbnQucmVjdDtcblxuICBjb25zdCB0YXJnZXQgPSB7XG4gICAgeDogZWxlbWVudC5yZWN0LnggKyBlbGVtZW50LnJlY3Qud2lkdGgsXG4gICAgeTogZWxlbWVudC5yZWN0LnkgKyBlbGVtZW50LnJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgc2V0QXR0cmlidXRlcyhsaW5lLCB7XG4gICAgeDE6IG9yaWdpbi54LFxuICAgIHkxOiBvcmlnaW4ueSxcbiAgICB4MjogdGFyZ2V0LngsXG4gICAgeTI6IHRhcmdldC55XG4gIH0pO1xuXG4gIGlmICghbWFya3VwLmxpbmVEZWNvcmF0aW9uKSByZXR1cm47XG5cbiAgYmVnaW4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZW5kLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgY29uc3QgdiA9IHZlY3Rvck5vcm1hbGl6ZSh7XG4gICAgeDogdGFyZ2V0LnggLSBvcmlnaW4ueCxcbiAgICB5OiB0YXJnZXQueSAtIG9yaWdpbi55XG4gIH0pO1xuXG4gIGNvbnN0IGwgPSBnZXRNYXJrdXBWYWx1ZSgwLjA1LCBzaXplLCBzY2FsZSk7XG5cbiAgaWYgKG1hcmt1cC5saW5lRGVjb3JhdGlvbi5pbmRleE9mKCdhcnJvdy1iZWdpbicpICE9PSAtMSkge1xuICAgIGNvbnN0IGFycm93QmVnaW5Sb3RhdGlvblBvaW50ID0gdmVjdG9yTXVsdGlwbHkodiwgbCk7XG4gICAgY29uc3QgYXJyb3dCZWdpbkNlbnRlciA9IHZlY3RvckFkZChvcmlnaW4sIGFycm93QmVnaW5Sb3RhdGlvblBvaW50KTtcbiAgICBjb25zdCBhcnJvd0JlZ2luQSA9IHZlY3RvclJvdGF0ZShvcmlnaW4sIDIsIGFycm93QmVnaW5DZW50ZXIpO1xuICAgIGNvbnN0IGFycm93QmVnaW5CID0gdmVjdG9yUm90YXRlKG9yaWdpbiwgLTIsIGFycm93QmVnaW5DZW50ZXIpO1xuXG4gICAgc2V0QXR0cmlidXRlcyhiZWdpbiwge1xuICAgICAgc3R5bGU6ICdkaXNwbGF5OmJsb2NrOycsXG4gICAgICBkOiBgTSR7YXJyb3dCZWdpbkEueH0sJHthcnJvd0JlZ2luQS55fSBMJHtvcmlnaW4ueH0sJHtvcmlnaW4ueX0gTCR7XG4gICAgICAgIGFycm93QmVnaW5CLnhcbiAgICAgIH0sJHthcnJvd0JlZ2luQi55fWBcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChtYXJrdXAubGluZURlY29yYXRpb24uaW5kZXhPZignYXJyb3ctZW5kJykgIT09IC0xKSB7XG4gICAgY29uc3QgYXJyb3dFbmRSb3RhdGlvblBvaW50ID0gdmVjdG9yTXVsdGlwbHkodiwgLWwpO1xuICAgIGNvbnN0IGFycm93RW5kQ2VudGVyID0gdmVjdG9yQWRkKHRhcmdldCwgYXJyb3dFbmRSb3RhdGlvblBvaW50KTtcbiAgICBjb25zdCBhcnJvd0VuZEEgPSB2ZWN0b3JSb3RhdGUodGFyZ2V0LCAyLCBhcnJvd0VuZENlbnRlcik7XG4gICAgY29uc3QgYXJyb3dFbmRCID0gdmVjdG9yUm90YXRlKHRhcmdldCwgLTIsIGFycm93RW5kQ2VudGVyKTtcblxuICAgIHNldEF0dHJpYnV0ZXMoZW5kLCB7XG4gICAgICBzdHlsZTogJ2Rpc3BsYXk6YmxvY2s7JyxcbiAgICAgIGQ6IGBNJHthcnJvd0VuZEEueH0sJHthcnJvd0VuZEEueX0gTCR7dGFyZ2V0Lnh9LCR7dGFyZ2V0Lnl9IEwke1xuICAgICAgICBhcnJvd0VuZEIueFxuICAgICAgfSwke2Fycm93RW5kQi55fWBcbiAgICB9KTtcbiAgfVxufTtcblxuY29uc3QgdXBkYXRlUGF0aCA9IChlbGVtZW50LCBtYXJrdXAsIHNpemUsIHNjYWxlKSA9PiB7XG4gIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwge1xuICAgIC4uLmVsZW1lbnQuc3R5bGVzLFxuICAgIGZpbGw6ICdub25lJyxcbiAgICBkOiBwb2ludHNUb1BhdGhTaGFwZShcbiAgICAgIG1hcmt1cC5wb2ludHMubWFwKHBvaW50ID0+ICh7XG4gICAgICAgIHg6IGdldE1hcmt1cFZhbHVlKHBvaW50LngsIHNpemUsIHNjYWxlLCAnd2lkdGgnKSxcbiAgICAgICAgeTogZ2V0TWFya3VwVmFsdWUocG9pbnQueSwgc2l6ZSwgc2NhbGUsICdoZWlnaHQnKVxuICAgICAgfSkpXG4gICAgKVxuICB9KTtcbn07XG5cbmNvbnN0IGNyZWF0ZVNoYXBlID0gbm9kZSA9PiBtYXJrdXAgPT4gc3ZnKG5vZGUsIHsgaWQ6IG1hcmt1cC5pZCB9KTtcblxuY29uc3QgY3JlYXRlSW1hZ2UgPSBtYXJrdXAgPT4ge1xuICBjb25zdCBzaGFwZSA9IHN2ZygnaW1hZ2UnLCB7XG4gICAgaWQ6IG1hcmt1cC5pZCxcbiAgICAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnLFxuICAgICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnLFxuICAgIG9wYWNpdHk6ICcwJ1xuICB9KTtcbiAgc2hhcGUub25sb2FkID0gKCkgPT4ge1xuICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIG1hcmt1cC5vcGFjaXR5IHx8IDEpO1xuICB9O1xuICBzaGFwZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgJ3hsaW5rOmhyZWYnLFxuICAgIG1hcmt1cC5zcmNcbiAgKTtcbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuY29uc3QgY3JlYXRlTGluZSA9IG1hcmt1cCA9PiB7XG4gIGNvbnN0IHNoYXBlID0gc3ZnKCdnJywge1xuICAgIGlkOiBtYXJrdXAuaWQsXG4gICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJ1xuICB9KTtcblxuICBjb25zdCBsaW5lID0gc3ZnKCdsaW5lJyk7XG4gIHNoYXBlLmFwcGVuZENoaWxkKGxpbmUpO1xuXG4gIGNvbnN0IGJlZ2luID0gc3ZnKCdwYXRoJyk7XG4gIHNoYXBlLmFwcGVuZENoaWxkKGJlZ2luKTtcblxuICBjb25zdCBlbmQgPSBzdmcoJ3BhdGgnKTtcbiAgc2hhcGUuYXBwZW5kQ2hpbGQoZW5kKTtcblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5jb25zdCBDUkVBVEVfVFlQRV9ST1VURVMgPSB7XG4gIGltYWdlOiBjcmVhdGVJbWFnZSxcbiAgcmVjdDogY3JlYXRlU2hhcGUoJ3JlY3QnKSxcbiAgZWxsaXBzZTogY3JlYXRlU2hhcGUoJ2VsbGlwc2UnKSxcbiAgdGV4dDogY3JlYXRlU2hhcGUoJ3RleHQnKSxcbiAgcGF0aDogY3JlYXRlU2hhcGUoJ3BhdGgnKSxcbiAgbGluZTogY3JlYXRlTGluZVxufTtcblxuY29uc3QgVVBEQVRFX1RZUEVfUk9VVEVTID0ge1xuICByZWN0OiB1cGRhdGVSZWN0LFxuICBlbGxpcHNlOiB1cGRhdGVFbGxpcHNlLFxuICBpbWFnZTogdXBkYXRlSW1hZ2UsXG4gIHRleHQ6IHVwZGF0ZVRleHQsXG4gIHBhdGg6IHVwZGF0ZVBhdGgsXG4gIGxpbmU6IHVwZGF0ZUxpbmVcbn07XG5cbmNvbnN0IGNyZWF0ZU1hcmt1cEJ5VHlwZSA9ICh0eXBlLCBtYXJrdXApID0+IENSRUFURV9UWVBFX1JPVVRFU1t0eXBlXShtYXJrdXApO1xuXG5jb25zdCB1cGRhdGVNYXJrdXBCeVR5cGUgPSAoZWxlbWVudCwgdHlwZSwgbWFya3VwLCBzaXplLCBzY2FsZSkgPT4ge1xuICBpZiAodHlwZSAhPT0gJ3BhdGgnKSB7XG4gICAgZWxlbWVudC5yZWN0ID0gZ2V0TWFya3VwUmVjdChtYXJrdXAsIHNpemUsIHNjYWxlKTtcbiAgfVxuICBlbGVtZW50LnN0eWxlcyA9IGdldE1hcmt1cFN0eWxlcyhtYXJrdXAsIHNpemUsIHNjYWxlKTtcbiAgVVBEQVRFX1RZUEVfUk9VVEVTW3R5cGVdKGVsZW1lbnQsIG1hcmt1cCwgc2l6ZSwgc2NhbGUpO1xufTtcblxuY29uc3QgTUFSS1VQX1JFQ1QgPSBbXG4gICd4JyxcbiAgJ3knLFxuICAnbGVmdCcsXG4gICd0b3AnLFxuICAncmlnaHQnLFxuICAnYm90dG9tJyxcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCdcbl07XG5cbmNvbnN0IHRvT3B0aW9uYWxGcmFjdGlvbiA9IHZhbHVlID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgLyUvLnRlc3QodmFsdWUpXG4gICAgPyBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgIDogdmFsdWU7XG5cbi8vIGFkZHMgZGVmYXVsdCBtYXJrdXAgcHJvcGVydGllcywgY2xvbmVzIG1hcmt1cFxuY29uc3QgcHJlcGFyZU1hcmt1cCA9IG1hcmt1cCA9PiB7XG4gIGNvbnN0IFt0eXBlLCBwcm9wc10gPSBtYXJrdXA7XG5cbiAgY29uc3QgcmVjdCA9IHByb3BzLnBvaW50c1xuICAgID8ge31cbiAgICA6IE1BUktVUF9SRUNULnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICBwcmV2W2N1cnJdID0gdG9PcHRpb25hbEZyYWN0aW9uKHByb3BzW2N1cnJdKTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9LCB7fSk7XG5cbiAgcmV0dXJuIFtcbiAgICB0eXBlLFxuICAgIHtcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIC4uLnByb3BzLFxuICAgICAgLi4ucmVjdFxuICAgIH1cbiAgXTtcbn07XG5cbmNvbnN0IHNvcnRNYXJrdXBCeVpJbmRleCA9IChhLCBiKSA9PiB7XG4gIGlmIChhWzFdLnpJbmRleCA+IGJbMV0uekluZGV4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKGFbMV0uekluZGV4IDwgYlsxXS56SW5kZXgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5jb25zdCBjcmVhdGVNYXJrdXBWaWV3ID0gXyA9PlxuICBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdpbWFnZS1wcmV2aWV3LW1hcmt1cCcsXG4gICAgdGFnOiAnc3ZnJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIG1peGluczoge1xuICAgICAgYXBpczogWyd3aWR0aCcsICdoZWlnaHQnLCAnY3JvcCcsICdtYXJrdXAnLCAncmVzaXplJywgJ2RpcnR5J11cbiAgICB9LFxuICAgIHdyaXRlOiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICBpZiAoIXByb3BzLmRpcnR5KSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHsgY3JvcCwgcmVzaXplLCBtYXJrdXAgfSA9IHByb3BzO1xuXG4gICAgICBjb25zdCB2aWV3V2lkdGggPSBwcm9wcy53aWR0aDtcbiAgICAgIGNvbnN0IHZpZXdIZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XG5cbiAgICAgIGxldCBjcm9wV2lkdGggPSBjcm9wLndpZHRoO1xuICAgICAgbGV0IGNyb3BIZWlnaHQgPSBjcm9wLmhlaWdodDtcblxuICAgICAgaWYgKHJlc2l6ZSkge1xuICAgICAgICBjb25zdCB7IHNpemUgfSA9IHJlc2l6ZTtcblxuICAgICAgICBsZXQgb3V0cHV0V2lkdGggPSBzaXplICYmIHNpemUud2lkdGg7XG4gICAgICAgIGxldCBvdXRwdXRIZWlnaHQgPSBzaXplICYmIHNpemUuaGVpZ2h0O1xuICAgICAgICBjb25zdCBvdXRwdXRGaXQgPSByZXNpemUubW9kZTtcbiAgICAgICAgY29uc3Qgb3V0cHV0VXBzY2FsZSA9IHJlc2l6ZS51cHNjYWxlO1xuXG4gICAgICAgIGlmIChvdXRwdXRXaWR0aCAmJiAhb3V0cHV0SGVpZ2h0KSBvdXRwdXRIZWlnaHQgPSBvdXRwdXRXaWR0aDtcbiAgICAgICAgaWYgKG91dHB1dEhlaWdodCAmJiAhb3V0cHV0V2lkdGgpIG91dHB1dFdpZHRoID0gb3V0cHV0SGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IHNob3VsZFVwc2NhbGUgPVxuICAgICAgICAgIGNyb3BXaWR0aCA8IG91dHB1dFdpZHRoICYmIGNyb3BIZWlnaHQgPCBvdXRwdXRIZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFzaG91bGRVcHNjYWxlIHx8IChzaG91bGRVcHNjYWxlICYmIG91dHB1dFVwc2NhbGUpKSB7XG4gICAgICAgICAgbGV0IHNjYWxhcldpZHRoID0gb3V0cHV0V2lkdGggLyBjcm9wV2lkdGg7XG4gICAgICAgICAgbGV0IHNjYWxhckhlaWdodCA9IG91dHB1dEhlaWdodCAvIGNyb3BIZWlnaHQ7XG5cbiAgICAgICAgICBpZiAob3V0cHV0Rml0ID09PSAnZm9yY2UnKSB7XG4gICAgICAgICAgICBjcm9wV2lkdGggPSBvdXRwdXRXaWR0aDtcbiAgICAgICAgICAgIGNyb3BIZWlnaHQgPSBvdXRwdXRIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzY2FsYXI7XG4gICAgICAgICAgICBpZiAob3V0cHV0Rml0ID09PSAnY292ZXInKSB7XG4gICAgICAgICAgICAgIHNjYWxhciA9IE1hdGgubWF4KHNjYWxhcldpZHRoLCBzY2FsYXJIZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvdXRwdXRGaXQgPT09ICdjb250YWluJykge1xuICAgICAgICAgICAgICBzY2FsYXIgPSBNYXRoLm1pbihzY2FsYXJXaWR0aCwgc2NhbGFySGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyb3BXaWR0aCA9IGNyb3BXaWR0aCAqIHNjYWxhcjtcbiAgICAgICAgICAgIGNyb3BIZWlnaHQgPSBjcm9wSGVpZ2h0ICogc2NhbGFyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICB3aWR0aDogdmlld1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHZpZXdIZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIHJvb3QuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS53aWR0aCk7XG4gICAgICByb290LmVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLmhlaWdodCk7XG5cbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4odmlld1dpZHRoIC8gY3JvcFdpZHRoLCB2aWV3SGVpZ2h0IC8gY3JvcEhlaWdodCk7XG5cbiAgICAgIC8vIGNsZWFyXG4gICAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgIC8vIGdldCBmaWx0ZXJcbiAgICAgIGNvbnN0IG1hcmt1cEZpbHRlciA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01BUktVUF9GSUxURVInKTtcblxuICAgICAgLy8gZHJhdyBuZXdcbiAgICAgIG1hcmt1cFxuICAgICAgICAuZmlsdGVyKG1hcmt1cEZpbHRlcilcbiAgICAgICAgLm1hcChwcmVwYXJlTWFya3VwKVxuICAgICAgICAuc29ydChzb3J0TWFya3VwQnlaSW5kZXgpXG4gICAgICAgIC5mb3JFYWNoKG1hcmt1cCA9PiB7XG4gICAgICAgICAgY29uc3QgW3R5cGUsIHNldHRpbmdzXSA9IG1hcmt1cDtcblxuICAgICAgICAgIC8vIGNyZWF0ZVxuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVNYXJrdXBCeVR5cGUodHlwZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlXG4gICAgICAgICAgdXBkYXRlTWFya3VwQnlUeXBlKGVsZW1lbnQsIHR5cGUsIHNldHRpbmdzLCBzaXplLCBzY2FsZSk7XG5cbiAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbmNvbnN0IGNyZWF0ZVZlY3RvciQxID0gKHgsIHkpID0+ICh7IHgsIHkgfSk7XG5cbmNvbnN0IHZlY3RvckRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG5cbmNvbnN0IHZlY3RvclN1YnRyYWN0ID0gKGEsIGIpID0+IGNyZWF0ZVZlY3RvciQxKGEueCAtIGIueCwgYS55IC0gYi55KTtcblxuY29uc3QgdmVjdG9yRGlzdGFuY2VTcXVhcmVkID0gKGEsIGIpID0+XG4gIHZlY3RvckRvdCh2ZWN0b3JTdWJ0cmFjdChhLCBiKSwgdmVjdG9yU3VidHJhY3QoYSwgYikpO1xuXG5jb25zdCB2ZWN0b3JEaXN0YW5jZSA9IChhLCBiKSA9PiBNYXRoLnNxcnQodmVjdG9yRGlzdGFuY2VTcXVhcmVkKGEsIGIpKTtcblxuY29uc3QgZ2V0T2Zmc2V0UG9pbnRPbkVkZ2UgPSAobGVuZ3RoLCByb3RhdGlvbikgPT4ge1xuICBjb25zdCBhID0gbGVuZ3RoO1xuXG4gIGNvbnN0IEEgPSAxLjU3MDc5NjMyNjc5NDg5NjY7XG4gIGNvbnN0IEIgPSByb3RhdGlvbjtcbiAgY29uc3QgQyA9IDEuNTcwNzk2MzI2Nzk0ODk2NiAtIHJvdGF0aW9uO1xuXG4gIGNvbnN0IHNpbkEgPSBNYXRoLnNpbihBKTtcbiAgY29uc3Qgc2luQiA9IE1hdGguc2luKEIpO1xuICBjb25zdCBzaW5DID0gTWF0aC5zaW4oQyk7XG4gIGNvbnN0IGNvc0MgPSBNYXRoLmNvcyhDKTtcbiAgY29uc3QgcmF0aW8gPSBhIC8gc2luQTtcbiAgY29uc3QgYiA9IHJhdGlvICogc2luQjtcbiAgY29uc3QgYyA9IHJhdGlvICogc2luQztcblxuICByZXR1cm4gY3JlYXRlVmVjdG9yJDEoY29zQyAqIGIsIGNvc0MgKiBjKTtcbn07XG5cbmNvbnN0IGdldFJvdGF0ZWRSZWN0U2l6ZSA9IChyZWN0LCByb3RhdGlvbikgPT4ge1xuICBjb25zdCB3ID0gcmVjdC53aWR0aDtcbiAgY29uc3QgaCA9IHJlY3QuaGVpZ2h0O1xuXG4gIGNvbnN0IGhvciA9IGdldE9mZnNldFBvaW50T25FZGdlKHcsIHJvdGF0aW9uKTtcbiAgY29uc3QgdmVyID0gZ2V0T2Zmc2V0UG9pbnRPbkVkZ2UoaCwgcm90YXRpb24pO1xuXG4gIGNvbnN0IHRsID0gY3JlYXRlVmVjdG9yJDEocmVjdC54ICsgTWF0aC5hYnMoaG9yLngpLCByZWN0LnkgLSBNYXRoLmFicyhob3IueSkpO1xuXG4gIGNvbnN0IHRyID0gY3JlYXRlVmVjdG9yJDEoXG4gICAgcmVjdC54ICsgcmVjdC53aWR0aCArIE1hdGguYWJzKHZlci55KSxcbiAgICByZWN0LnkgKyBNYXRoLmFicyh2ZXIueClcbiAgKTtcblxuICBjb25zdCBibCA9IGNyZWF0ZVZlY3RvciQxKFxuICAgIHJlY3QueCAtIE1hdGguYWJzKHZlci55KSxcbiAgICByZWN0LnkgKyByZWN0LmhlaWdodCAtIE1hdGguYWJzKHZlci54KVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHZlY3RvckRpc3RhbmNlKHRsLCB0ciksXG4gICAgaGVpZ2h0OiB2ZWN0b3JEaXN0YW5jZSh0bCwgYmwpXG4gIH07XG59O1xuXG5jb25zdCBjYWxjdWxhdGVDYW52YXNTaXplID0gKGltYWdlLCBjYW52YXNBc3BlY3RSYXRpbywgem9vbSA9IDEpID0+IHtcbiAgY29uc3QgaW1hZ2VBc3BlY3RSYXRpbyA9IGltYWdlLmhlaWdodCAvIGltYWdlLndpZHRoO1xuXG4gIC8vIGRldGVybWluZSBhY3R1YWwgcGl4ZWxzIG9uIHggYW5kIHkgYXhpc1xuICBsZXQgY2FudmFzV2lkdGggPSAxO1xuICBsZXQgY2FudmFzSGVpZ2h0ID0gY2FudmFzQXNwZWN0UmF0aW87XG4gIGxldCBpbWdXaWR0aCA9IDE7XG4gIGxldCBpbWdIZWlnaHQgPSBpbWFnZUFzcGVjdFJhdGlvO1xuICBpZiAoaW1nSGVpZ2h0ID4gY2FudmFzSGVpZ2h0KSB7XG4gICAgaW1nSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIGltZ1dpZHRoID0gaW1nSGVpZ2h0IC8gaW1hZ2VBc3BlY3RSYXRpbztcbiAgfVxuXG4gIGNvbnN0IHNjYWxhciA9IE1hdGgubWF4KGNhbnZhc1dpZHRoIC8gaW1nV2lkdGgsIGNhbnZhc0hlaWdodCAvIGltZ0hlaWdodCk7XG4gIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGggLyAoem9vbSAqIHNjYWxhciAqIGltZ1dpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gd2lkdGggKiBjYW52YXNBc3BlY3RSYXRpbztcblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufTtcblxuY29uc3QgZ2V0SW1hZ2VSZWN0Wm9vbUZhY3RvciA9IChpbWFnZVJlY3QsIGNyb3BSZWN0LCByb3RhdGlvbiwgY2VudGVyKSA9PiB7XG4gIC8vIGNhbGN1bGF0ZSBhdmFpbGFibGUgc3BhY2Ugcm91bmQgaW1hZ2UgY2VudGVyIHBvc2l0aW9uXG4gIGNvbnN0IGN4ID0gY2VudGVyLnggPiAwLjUgPyAxIC0gY2VudGVyLnggOiBjZW50ZXIueDtcbiAgY29uc3QgY3kgPSBjZW50ZXIueSA+IDAuNSA/IDEgLSBjZW50ZXIueSA6IGNlbnRlci55O1xuICBjb25zdCBpbWFnZVdpZHRoID0gY3ggKiAyICogaW1hZ2VSZWN0LndpZHRoO1xuICBjb25zdCBpbWFnZUhlaWdodCA9IGN5ICogMiAqIGltYWdlUmVjdC5oZWlnaHQ7XG5cbiAgLy8gY2FsY3VsYXRlIHJvdGF0ZWQgY3JvcCByZWN0YW5nbGUgc2l6ZVxuICBjb25zdCByb3RhdGVkQ3JvcFNpemUgPSBnZXRSb3RhdGVkUmVjdFNpemUoY3JvcFJlY3QsIHJvdGF0aW9uKTtcblxuICAvLyBjYWxjdWxhdGUgc2NhbGFyIHJlcXVpcmVkIHRvIGZpdCBpbWFnZVxuICByZXR1cm4gTWF0aC5tYXgoXG4gICAgcm90YXRlZENyb3BTaXplLndpZHRoIC8gaW1hZ2VXaWR0aCxcbiAgICByb3RhdGVkQ3JvcFNpemUuaGVpZ2h0IC8gaW1hZ2VIZWlnaHRcbiAgKTtcbn07XG5cbmNvbnN0IGdldENlbnRlcmVkQ3JvcFJlY3QgPSAoY29udGFpbmVyLCBhc3BlY3RSYXRpbykgPT4ge1xuICBsZXQgd2lkdGggPSBjb250YWluZXIud2lkdGg7XG4gIGxldCBoZWlnaHQgPSB3aWR0aCAqIGFzcGVjdFJhdGlvO1xuICBpZiAoaGVpZ2h0ID4gY29udGFpbmVyLmhlaWdodCkge1xuICAgIGhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgd2lkdGggPSBoZWlnaHQgLyBhc3BlY3RSYXRpbztcbiAgfVxuICBjb25zdCB4ID0gKGNvbnRhaW5lci53aWR0aCAtIHdpZHRoKSAqIDAuNTtcbiAgY29uc3QgeSA9IChjb250YWluZXIuaGVpZ2h0IC0gaGVpZ2h0KSAqIDAuNTtcblxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn07XG5cbmNvbnN0IGdldEN1cnJlbnRDcm9wU2l6ZSA9IChpbWFnZVNpemUsIGNyb3AgPSB7fSkgPT4ge1xuICBsZXQgeyB6b29tLCByb3RhdGlvbiwgY2VudGVyLCBhc3BlY3RSYXRpbyB9ID0gY3JvcDtcblxuICBpZiAoIWFzcGVjdFJhdGlvKSBhc3BlY3RSYXRpbyA9IGltYWdlU2l6ZS5oZWlnaHQgLyBpbWFnZVNpemUud2lkdGg7XG5cbiAgY29uc3QgY2FudmFzU2l6ZSA9IGNhbGN1bGF0ZUNhbnZhc1NpemUoaW1hZ2VTaXplLCBhc3BlY3RSYXRpbywgem9vbSk7XG5cbiAgY29uc3QgY2FudmFzQ2VudGVyID0ge1xuICAgIHg6IGNhbnZhc1NpemUud2lkdGggKiAwLjUsXG4gICAgeTogY2FudmFzU2l6ZS5oZWlnaHQgKiAwLjVcbiAgfTtcblxuICBjb25zdCBzdGFnZSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IGNhbnZhc1NpemUud2lkdGgsXG4gICAgaGVpZ2h0OiBjYW52YXNTaXplLmhlaWdodCxcbiAgICBjZW50ZXI6IGNhbnZhc0NlbnRlclxuICB9O1xuXG4gIGNvbnN0IHNob3VsZExpbWl0ID0gdHlwZW9mIGNyb3Auc2NhbGVUb0ZpdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY3JvcC5zY2FsZVRvRml0O1xuXG4gIGNvbnN0IHN0YWdlWm9vbUZhY3RvciA9IGdldEltYWdlUmVjdFpvb21GYWN0b3IoXG4gICAgaW1hZ2VTaXplLFxuICAgIGdldENlbnRlcmVkQ3JvcFJlY3Qoc3RhZ2UsIGFzcGVjdFJhdGlvKSxcbiAgICByb3RhdGlvbixcbiAgICBzaG91bGRMaW1pdCA/IGNlbnRlciA6IHsgeDogMC41LCB5OiAwLjUgfVxuICApO1xuXG4gIGNvbnN0IHNjYWxlID0gem9vbSAqIHN0YWdlWm9vbUZhY3RvcjtcblxuICAvLyBzdGFydCBkcmF3aW5nXG4gIHJldHVybiB7XG4gICAgd2lkdGhGbG9hdDogY2FudmFzU2l6ZS53aWR0aCAvIHNjYWxlLFxuICAgIGhlaWdodEZsb2F0OiBjYW52YXNTaXplLmhlaWdodCAvIHNjYWxlLFxuICAgIHdpZHRoOiBNYXRoLnJvdW5kKGNhbnZhc1NpemUud2lkdGggLyBzY2FsZSksXG4gICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGNhbnZhc1NpemUuaGVpZ2h0IC8gc2NhbGUpXG4gIH07XG59O1xuXG5jb25zdCBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMgPSB7XG4gIHR5cGU6ICdzcHJpbmcnLFxuICBzdGlmZm5lc3M6IDAuNSxcbiAgZGFtcGluZzogMC40NSxcbiAgbWFzczogMTBcbn07XG5cbi8vIGRvZXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZmxpcHBpbmdcbmNvbnN0IGNyZWF0ZUJpdG1hcFZpZXcgPSBfID0+XG4gIF8udXRpbHMuY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2ltYWdlLWJpdG1hcCcsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBtaXhpbnM6IHsgc3R5bGVzOiBbJ3NjYWxlWCcsICdzY2FsZVknXSB9LFxuICAgIGNyZWF0ZTogKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgICAgcm9vdC5hcHBlbmRDaGlsZChwcm9wcy5pbWFnZSk7XG4gICAgfVxuICB9KTtcblxuLy8gc2hpZnRzIGFuZCByb3RhdGVzIGltYWdlXG5jb25zdCBjcmVhdGVJbWFnZUNhbnZhc1dyYXBwZXIgPSBfID0+XG4gIF8udXRpbHMuY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2ltYWdlLWNhbnZhcy13cmFwcGVyJyxcbiAgICB0YWc6ICdkaXYnLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbJ2Nyb3AnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gICAgICBzdHlsZXM6IFtcbiAgICAgICAgJ29yaWdpblgnLFxuICAgICAgICAnb3JpZ2luWScsXG4gICAgICAgICd0cmFuc2xhdGVYJyxcbiAgICAgICAgJ3RyYW5zbGF0ZVknLFxuICAgICAgICAnc2NhbGVYJyxcbiAgICAgICAgJ3NjYWxlWScsXG4gICAgICAgICdyb3RhdGVaJ1xuICAgICAgXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgb3JpZ2luWDogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICBvcmlnaW5ZOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgIHNjYWxlWDogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICBzY2FsZVk6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgdHJhbnNsYXRlWDogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICB0cmFuc2xhdGVZOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgIHJvdGF0ZVo6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QU1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlOiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICBwcm9wcy53aWR0aCA9IHByb3BzLmltYWdlLndpZHRoO1xuICAgICAgcHJvcHMuaGVpZ2h0ID0gcHJvcHMuaW1hZ2UuaGVpZ2h0O1xuICAgICAgcm9vdC5yZWYuYml0bWFwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGNyZWF0ZUJpdG1hcFZpZXcoXyksIHsgaW1hZ2U6IHByb3BzLmltYWdlIH0pXG4gICAgICApO1xuICAgIH0sXG4gICAgd3JpdGU6ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgZmxpcCB9ID0gcHJvcHMuY3JvcDtcbiAgICAgIGNvbnN0IHsgYml0bWFwIH0gPSByb290LnJlZjtcbiAgICAgIGJpdG1hcC5zY2FsZVggPSBmbGlwLmhvcml6b250YWwgPyAtMSA6IDE7XG4gICAgICBiaXRtYXAuc2NhbGVZID0gZmxpcC52ZXJ0aWNhbCA/IC0xIDogMTtcbiAgICB9XG4gIH0pO1xuXG4vLyBjbGlwcyBjYW52YXMgdG8gY29ycmVjdCBhc3BlY3QgcmF0aW9cbmNvbnN0IGNyZWF0ZUNsaXBWaWV3ID0gXyA9PlxuICBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdpbWFnZS1jbGlwJyxcbiAgICB0YWc6ICdkaXYnLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbXG4gICAgICAgICdjcm9wJyxcbiAgICAgICAgJ21hcmt1cCcsXG4gICAgICAgICdyZXNpemUnLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgJ2RpcnR5JyxcbiAgICAgICAgJ2JhY2tncm91bmQnXG4gICAgICBdLFxuICAgICAgc3R5bGVzOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdvcGFjaXR5J10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWRXcml0ZVZpZXc6IGZ1bmN0aW9uKHsgcm9vdCwgcHJvcHMgfSkge1xuICAgICAgaWYgKCFwcm9wcy5iYWNrZ3JvdW5kKSByZXR1cm47XG4gICAgICByb290LmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcHJvcHMuYmFja2dyb3VuZDtcbiAgICB9LFxuICAgIGNyZWF0ZTogKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgICAgcm9vdC5yZWYuaW1hZ2UgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoXG4gICAgICAgICAgY3JlYXRlSW1hZ2VDYW52YXNXcmFwcGVyKF8pLFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICByb290LnJlZi5jcmVhdGVNYXJrdXAgPSAoKSA9PiB7XG4gICAgICAgIGlmIChyb290LnJlZi5tYXJrdXApIHJldHVybjtcbiAgICAgICAgcm9vdC5yZWYubWFya3VwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoY3JlYXRlTWFya3VwVmlldyhfKSwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcm9vdC5yZWYuZGVzdHJveU1hcmt1cCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFyb290LnJlZi5tYXJrdXApIHJldHVybjtcbiAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcocm9vdC5yZWYubWFya3VwKTtcbiAgICAgICAgcm9vdC5yZWYubWFya3VwID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8vIHNldCB1cCB0cmFuc3BhcmVuY3kgZ3JpZFxuICAgICAgY29uc3QgdHJhbnNwYXJlbmN5SW5kaWNhdG9yID0gcm9vdC5xdWVyeShcbiAgICAgICAgJ0dFVF9JTUFHRV9QUkVWSUVXX1RSQU5TUEFSRU5DWV9JTkRJQ0FUT1InXG4gICAgICApO1xuICAgICAgaWYgKHRyYW5zcGFyZW5jeUluZGljYXRvciA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAvLyBncmlkIHBhdHRlcm5cbiAgICAgIGlmICh0cmFuc3BhcmVuY3lJbmRpY2F0b3IgPT09ICdncmlkJykge1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC50cmFuc3BhcmVuY3lJbmRpY2F0b3IgPSB0cmFuc3BhcmVuY3lJbmRpY2F0b3I7XG4gICAgICB9XG4gICAgICAvLyBiYXNpYyBjb2xvclxuICAgICAgZWxzZSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnRyYW5zcGFyZW5jeUluZGljYXRvciA9ICdjb2xvcic7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0ZTogKHsgcm9vdCwgcHJvcHMsIHNob3VsZE9wdGltaXplIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY3JvcCwgbWFya3VwLCByZXNpemUsIGRpcnR5LCB3aWR0aCwgaGVpZ2h0IH0gPSBwcm9wcztcblxuICAgICAgcm9vdC5yZWYuaW1hZ2UuY3JvcCA9IGNyb3A7XG5cbiAgICAgIGNvbnN0IHN0YWdlID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICB4OiB3aWR0aCAqIDAuNSxcbiAgICAgICAgICB5OiBoZWlnaHQgKiAwLjVcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgaW1hZ2UgPSB7XG4gICAgICAgIHdpZHRoOiByb290LnJlZi5pbWFnZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByb290LnJlZi5pbWFnZS5oZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9yaWdpbiA9IHtcbiAgICAgICAgeDogY3JvcC5jZW50ZXIueCAqIGltYWdlLndpZHRoLFxuICAgICAgICB5OiBjcm9wLmNlbnRlci55ICogaW1hZ2UuaGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogc3RhZ2UuY2VudGVyLnggLSBpbWFnZS53aWR0aCAqIGNyb3AuY2VudGVyLngsXG4gICAgICAgIHk6IHN0YWdlLmNlbnRlci55IC0gaW1hZ2UuaGVpZ2h0ICogY3JvcC5jZW50ZXIueVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgcm90YXRpb24gPSBNYXRoLlBJICogMiArIChjcm9wLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyKSk7XG5cbiAgICAgIGNvbnN0IGNyb3BBc3BlY3RSYXRpbyA9IGNyb3AuYXNwZWN0UmF0aW8gfHwgaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGg7XG5cbiAgICAgIGNvbnN0IHNob3VsZExpbWl0ID1cbiAgICAgICAgdHlwZW9mIGNyb3Auc2NhbGVUb0ZpdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY3JvcC5zY2FsZVRvRml0O1xuXG4gICAgICBjb25zdCBzdGFnZVpvb21GYWN0b3IgPSBnZXRJbWFnZVJlY3Rab29tRmFjdG9yKFxuICAgICAgICBpbWFnZSxcbiAgICAgICAgZ2V0Q2VudGVyZWRDcm9wUmVjdChzdGFnZSwgY3JvcEFzcGVjdFJhdGlvKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHNob3VsZExpbWl0ID8gY3JvcC5jZW50ZXIgOiB7IHg6IDAuNSwgeTogMC41IH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNjYWxlID0gY3JvcC56b29tICogc3RhZ2Vab29tRmFjdG9yO1xuXG4gICAgICAvLyB1cGRhdGUgbWFya3VwIHZpZXdcbiAgICAgIGlmIChtYXJrdXAgJiYgbWFya3VwLmxlbmd0aCkge1xuICAgICAgICByb290LnJlZi5jcmVhdGVNYXJrdXAoKTtcbiAgICAgICAgcm9vdC5yZWYubWFya3VwLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHJvb3QucmVmLm1hcmt1cC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJvb3QucmVmLm1hcmt1cC5yZXNpemUgPSByZXNpemU7XG4gICAgICAgIHJvb3QucmVmLm1hcmt1cC5kaXJ0eSA9IGRpcnR5O1xuICAgICAgICByb290LnJlZi5tYXJrdXAubWFya3VwID0gbWFya3VwO1xuICAgICAgICByb290LnJlZi5tYXJrdXAuY3JvcCA9IGdldEN1cnJlbnRDcm9wU2l6ZShpbWFnZSwgY3JvcCk7XG4gICAgICB9IGVsc2UgaWYgKHJvb3QucmVmLm1hcmt1cCkge1xuICAgICAgICByb290LnJlZi5kZXN0cm95TWFya3VwKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBpbWFnZSB2aWV3XG4gICAgICBjb25zdCBpbWFnZVZpZXcgPSByb290LnJlZi5pbWFnZTtcblxuICAgICAgLy8gZG9uJ3QgdXBkYXRlIGNsaXAgbGF5b3V0XG4gICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgaW1hZ2VWaWV3Lm9yaWdpblggPSBudWxsO1xuICAgICAgICBpbWFnZVZpZXcub3JpZ2luWSA9IG51bGw7XG4gICAgICAgIGltYWdlVmlldy50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgaW1hZ2VWaWV3LnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICBpbWFnZVZpZXcucm90YXRlWiA9IG51bGw7XG4gICAgICAgIGltYWdlVmlldy5zY2FsZVggPSBudWxsO1xuICAgICAgICBpbWFnZVZpZXcuc2NhbGVZID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbWFnZVZpZXcub3JpZ2luWCA9IG9yaWdpbi54O1xuICAgICAgaW1hZ2VWaWV3Lm9yaWdpblkgPSBvcmlnaW4ueTtcbiAgICAgIGltYWdlVmlldy50cmFuc2xhdGVYID0gdHJhbnNsYXRpb24ueDtcbiAgICAgIGltYWdlVmlldy50cmFuc2xhdGVZID0gdHJhbnNsYXRpb24ueTtcbiAgICAgIGltYWdlVmlldy5yb3RhdGVaID0gcm90YXRpb247XG4gICAgICBpbWFnZVZpZXcuc2NhbGVYID0gc2NhbGU7XG4gICAgICBpbWFnZVZpZXcuc2NhbGVZID0gc2NhbGU7XG4gICAgfVxuICB9KTtcblxuY29uc3QgY3JlYXRlSW1hZ2VWaWV3ID0gXyA9PlxuICBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdpbWFnZS1wcmV2aWV3JyxcbiAgICB0YWc6ICdkaXYnLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbJ2ltYWdlJywgJ2Nyb3AnLCAnbWFya3VwJywgJ3Jlc2l6ZScsICdkaXJ0eScsICdiYWNrZ3JvdW5kJ10sXG4gICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgc2NhbGVYOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgIHNjYWxlWTogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICB0cmFuc2xhdGVZOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDQwMCB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGU6ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAgIHJvb3QucmVmLmNsaXAgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoY3JlYXRlQ2xpcFZpZXcoXyksIHtcbiAgICAgICAgICBpZDogcHJvcHMuaWQsXG4gICAgICAgICAgaW1hZ2U6IHByb3BzLmltYWdlLFxuICAgICAgICAgIGNyb3A6IHByb3BzLmNyb3AsXG4gICAgICAgICAgbWFya3VwOiBwcm9wcy5tYXJrdXAsXG4gICAgICAgICAgcmVzaXplOiBwcm9wcy5yZXNpemUsXG4gICAgICAgICAgZGlydHk6IHByb3BzLmRpcnR5LFxuICAgICAgICAgIGJhY2tncm91bmQ6IHByb3BzLmJhY2tncm91bmRcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcbiAgICB3cml0ZTogKHsgcm9vdCwgcHJvcHMsIHNob3VsZE9wdGltaXplIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY2xpcCB9ID0gcm9vdC5yZWY7XG5cbiAgICAgIGNvbnN0IHsgaW1hZ2UsIGNyb3AsIG1hcmt1cCwgcmVzaXplLCBkaXJ0eSB9ID0gcHJvcHM7XG5cbiAgICAgIGNsaXAuY3JvcCA9IGNyb3A7XG4gICAgICBjbGlwLm1hcmt1cCA9IG1hcmt1cDtcbiAgICAgIGNsaXAucmVzaXplID0gcmVzaXplO1xuICAgICAgY2xpcC5kaXJ0eSA9IGRpcnR5O1xuXG4gICAgICAvLyBkb24ndCB1cGRhdGUgY2xpcCBsYXlvdXRcbiAgICAgIGNsaXAub3BhY2l0eSA9IHNob3VsZE9wdGltaXplID8gMCA6IDE7XG5cbiAgICAgIC8vIGRvbid0IHJlLXJlbmRlciBpZiBvcHRpbWl6aW5nIG9yIGhpZGRlbiAod2lkdGggd2lsbCBiZSB6ZXJvIHJlc3VsdGluZyBpbiB3ZWlyZCBhbmltYXRpb25zKVxuICAgICAgaWYgKHNob3VsZE9wdGltaXplIHx8IHJvb3QucmVjdC5lbGVtZW50LmhpZGRlbikgcmV0dXJuO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgc2NhbGVkIHByZXZpZXcgaW1hZ2Ugc2l6ZVxuICAgICAgY29uc3QgaW1hZ2VBc3BlY3RSYXRpbyA9IGltYWdlLmhlaWdodCAvIGltYWdlLndpZHRoO1xuICAgICAgbGV0IGFzcGVjdFJhdGlvID0gY3JvcC5hc3BlY3RSYXRpbyB8fCBpbWFnZUFzcGVjdFJhdGlvO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgY29udGFpbmVyIHNpemVcbiAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gcm9vdC5yZWN0LmlubmVyLndpZHRoO1xuICAgICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gcm9vdC5yZWN0LmlubmVyLmhlaWdodDtcblxuICAgICAgbGV0IGZpeGVkUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0hFSUdIVCcpO1xuICAgICAgY29uc3QgbWluUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01JTl9IRUlHSFQnKTtcbiAgICAgIGNvbnN0IG1heFByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVhfSEVJR0hUJyk7XG5cbiAgICAgIGNvbnN0IHBhbmVsQXNwZWN0UmF0aW8gPSByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICBjb25zdCBhbGxvd011bHRpcGxlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX01VTFRJUExFJyk7XG5cbiAgICAgIGlmIChwYW5lbEFzcGVjdFJhdGlvICYmICFhbGxvd011bHRpcGxlKSB7XG4gICAgICAgIGZpeGVkUHJldmlld0hlaWdodCA9IGNvbnRhaW5lcldpZHRoICogcGFuZWxBc3BlY3RSYXRpbztcbiAgICAgICAgYXNwZWN0UmF0aW8gPSBwYW5lbEFzcGVjdFJhdGlvO1xuICAgICAgfVxuXG4gICAgICAvLyBkZXRlcm1pbmUgY2xpcCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBsZXQgY2xpcEhlaWdodCA9XG4gICAgICAgIGZpeGVkUHJldmlld0hlaWdodCAhPT0gbnVsbFxuICAgICAgICAgID8gZml4ZWRQcmV2aWV3SGVpZ2h0XG4gICAgICAgICAgOiBNYXRoLm1heChcbiAgICAgICAgICAgICAgbWluUHJldmlld0hlaWdodCxcbiAgICAgICAgICAgICAgTWF0aC5taW4oY29udGFpbmVyV2lkdGggKiBhc3BlY3RSYXRpbywgbWF4UHJldmlld0hlaWdodClcbiAgICAgICAgICAgICk7XG5cbiAgICAgIGxldCBjbGlwV2lkdGggPSBjbGlwSGVpZ2h0IC8gYXNwZWN0UmF0aW87XG4gICAgICBpZiAoY2xpcFdpZHRoID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgY2xpcFdpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gICAgICAgIGNsaXBIZWlnaHQgPSBjbGlwV2lkdGggKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKGNsaXBIZWlnaHQgPiBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgY2xpcEhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgY2xpcFdpZHRoID0gY29udGFpbmVySGVpZ2h0IC8gYXNwZWN0UmF0aW87XG4gICAgICB9XG5cbiAgICAgIGNsaXAud2lkdGggPSBjbGlwV2lkdGg7XG4gICAgICBjbGlwLmhlaWdodCA9IGNsaXBIZWlnaHQ7XG4gICAgfVxuICB9KTtcblxubGV0IFNWR19NQVNLID0gYDxzdmcgd2lkdGg9XCI1MDBcIiBoZWlnaHQ9XCIyMDBcIiB2aWV3Qm94PVwiMCAwIDUwMCAyMDBcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiPlxuICAgIDxkZWZzPlxuICAgICAgICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJncmFkaWVudC1fX1VJRF9fXCIgY3g9XCIuNVwiIGN5PVwiMS4yNVwiIHI9XCIxLjE1XCI+XG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9JzUwJScgc3RvcC1jb2xvcj0nIzAwMDAwMCcvPlxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSc1NiUnIHN0b3AtY29sb3I9JyMwYTBhMGEnLz5cbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0nNjMlJyBzdG9wLWNvbG9yPScjMjYyNjI2Jy8+XG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9JzY5JScgc3RvcC1jb2xvcj0nIzRmNGY0ZicvPlxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSc3NSUnIHN0b3AtY29sb3I9JyM4MDgwODAnLz5cbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0nODElJyBzdG9wLWNvbG9yPScjYjFiMWIxJy8+XG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9Jzg4JScgc3RvcC1jb2xvcj0nI2RhZGFkYScvPlxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSc5NCUnIHN0b3AtY29sb3I9JyNmNmY2ZjYnLz5cbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0nMTAwJScgc3RvcC1jb2xvcj0nI2ZmZmZmZicvPlxuICAgICAgICA8L3JhZGlhbEdyYWRpZW50PlxuICAgICAgICA8bWFzayBpZD1cIm1hc2stX19VSURfX1wiPlxuICAgICAgICAgICAgPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiNTAwXCIgaGVpZ2h0PVwiMjAwXCIgZmlsbD1cInVybCgjZ3JhZGllbnQtX19VSURfXylcIj48L3JlY3Q+XG4gICAgICAgIDwvbWFzaz5cbiAgICA8L2RlZnM+XG4gICAgPHJlY3QgeD1cIjBcIiB3aWR0aD1cIjUwMFwiIGhlaWdodD1cIjIwMFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBtYXNrPVwidXJsKCNtYXNrLV9fVUlEX18pXCI+PC9yZWN0PlxuPC9zdmc+YDtcblxubGV0IFNWR01hc2tVbmlxdWVJZCA9IDA7XG5cbmNvbnN0IGNyZWF0ZUltYWdlT3ZlcmxheVZpZXcgPSBmcEFQSSA9PlxuICBmcEFQSS51dGlscy5jcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnaW1hZ2UtcHJldmlldy1vdmVybGF5JyxcbiAgICB0YWc6ICdkaXYnLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgY3JlYXRlOiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICBsZXQgbWFzayA9IFNWR19NQVNLO1xuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKSkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhhc2gsICcnKVxuICAgICAgICApLmhyZWY7XG4gICAgICAgIG1hc2sgPSBtYXNrLnJlcGxhY2UoL3VybFxcKFxcIy9nLCAndXJsKCcgKyB1cmwgKyAnIycpO1xuICAgICAgfVxuXG4gICAgICBTVkdNYXNrVW5pcXVlSWQrKztcbiAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFxuICAgICAgICBgZmlsZXBvbmQtLWltYWdlLXByZXZpZXctb3ZlcmxheS0ke3Byb3BzLnN0YXR1c31gXG4gICAgICApO1xuICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IG1hc2sucmVwbGFjZSgvX19VSURfXy9nLCBTVkdNYXNrVW5pcXVlSWQpO1xuICAgIH0sXG4gICAgbWl4aW5zOiB7XG4gICAgICBzdHlsZXM6IFsnb3BhY2l0eSddLFxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICdzcHJpbmcnLCBtYXNzOiAyNSB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuLyoqXG4gKiBCaXRtYXAgV29ya2VyXG4gKi9cbmNvbnN0IEJpdG1hcFdvcmtlciA9IGZ1bmN0aW9uKCkge1xuICBzZWxmLm9ubWVzc2FnZSA9IGUgPT4ge1xuICAgIGNyZWF0ZUltYWdlQml0bWFwKGUuZGF0YS5tZXNzYWdlLmZpbGUpLnRoZW4oYml0bWFwID0+IHtcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBpZDogZS5kYXRhLmlkLCBtZXNzYWdlOiBiaXRtYXAgfSwgW2JpdG1hcF0pO1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDb2xvck1hdHJpeCBXb3JrZXJcbiAqL1xuY29uc3QgQ29sb3JNYXRyaXhXb3JrZXIgPSBmdW5jdGlvbigpIHtcbiAgc2VsZi5vbm1lc3NhZ2UgPSBlID0+IHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBlLmRhdGEubWVzc2FnZS5pbWFnZURhdGE7XG4gICAgY29uc3QgbWF0cml4ID0gZS5kYXRhLm1lc3NhZ2UuY29sb3JNYXRyaXg7XG5cbiAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgY29uc3QgbCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgY29uc3QgbTExID0gbWF0cml4WzBdO1xuICAgIGNvbnN0IG0xMiA9IG1hdHJpeFsxXTtcbiAgICBjb25zdCBtMTMgPSBtYXRyaXhbMl07XG4gICAgY29uc3QgbTE0ID0gbWF0cml4WzNdO1xuICAgIGNvbnN0IG0xNSA9IG1hdHJpeFs0XTtcblxuICAgIGNvbnN0IG0yMSA9IG1hdHJpeFs1XTtcbiAgICBjb25zdCBtMjIgPSBtYXRyaXhbNl07XG4gICAgY29uc3QgbTIzID0gbWF0cml4WzddO1xuICAgIGNvbnN0IG0yNCA9IG1hdHJpeFs4XTtcbiAgICBjb25zdCBtMjUgPSBtYXRyaXhbOV07XG5cbiAgICBjb25zdCBtMzEgPSBtYXRyaXhbMTBdO1xuICAgIGNvbnN0IG0zMiA9IG1hdHJpeFsxMV07XG4gICAgY29uc3QgbTMzID0gbWF0cml4WzEyXTtcbiAgICBjb25zdCBtMzQgPSBtYXRyaXhbMTNdO1xuICAgIGNvbnN0IG0zNSA9IG1hdHJpeFsxNF07XG5cbiAgICBjb25zdCBtNDEgPSBtYXRyaXhbMTVdO1xuICAgIGNvbnN0IG00MiA9IG1hdHJpeFsxNl07XG4gICAgY29uc3QgbTQzID0gbWF0cml4WzE3XTtcbiAgICBjb25zdCBtNDQgPSBtYXRyaXhbMThdO1xuICAgIGNvbnN0IG00NSA9IG1hdHJpeFsxOV07XG5cbiAgICBsZXQgaW5kZXggPSAwLFxuICAgICAgciA9IDAuMCxcbiAgICAgIGcgPSAwLjAsXG4gICAgICBiID0gMC4wLFxuICAgICAgYSA9IDAuMDtcblxuICAgIGZvciAoOyBpbmRleCA8IGw7IGluZGV4ICs9IDQpIHtcbiAgICAgIHIgPSBkYXRhW2luZGV4XSAvIDI1NTtcbiAgICAgIGcgPSBkYXRhW2luZGV4ICsgMV0gLyAyNTU7XG4gICAgICBiID0gZGF0YVtpbmRleCArIDJdIC8gMjU1O1xuICAgICAgYSA9IGRhdGFbaW5kZXggKyAzXSAvIDI1NTtcbiAgICAgIGRhdGFbaW5kZXhdID0gTWF0aC5tYXgoXG4gICAgICAgIDAsXG4gICAgICAgIE1hdGgubWluKChyICogbTExICsgZyAqIG0xMiArIGIgKiBtMTMgKyBhICogbTE0ICsgbTE1KSAqIDI1NSwgMjU1KVxuICAgICAgKTtcbiAgICAgIGRhdGFbaW5kZXggKyAxXSA9IE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICBNYXRoLm1pbigociAqIG0yMSArIGcgKiBtMjIgKyBiICogbTIzICsgYSAqIG0yNCArIG0yNSkgKiAyNTUsIDI1NSlcbiAgICAgICk7XG4gICAgICBkYXRhW2luZGV4ICsgMl0gPSBNYXRoLm1heChcbiAgICAgICAgMCxcbiAgICAgICAgTWF0aC5taW4oKHIgKiBtMzEgKyBnICogbTMyICsgYiAqIG0zMyArIGEgKiBtMzQgKyBtMzUpICogMjU1LCAyNTUpXG4gICAgICApO1xuICAgICAgZGF0YVtpbmRleCArIDNdID0gTWF0aC5tYXgoXG4gICAgICAgIDAsXG4gICAgICAgIE1hdGgubWluKChyICogbTQxICsgZyAqIG00MiArIGIgKiBtNDMgKyBhICogbTQ0ICsgbTQ1KSAqIDI1NSwgMjU1KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCwgbWVzc2FnZTogaW1hZ2VEYXRhIH0sIFtcbiAgICAgIGltYWdlRGF0YS5kYXRhLmJ1ZmZlclxuICAgIF0pO1xuICB9O1xufTtcblxuY29uc3QgZ2V0SW1hZ2VTaXplID0gKHVybCwgY2IpID0+IHtcbiAgbGV0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgIGltYWdlID0gbnVsbDtcbiAgICBjYih3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcbiAgaW1hZ2Uuc3JjID0gdXJsO1xufTtcblxuY29uc3QgdHJhbnNmb3JtcyA9IHtcbiAgMTogKCkgPT4gWzEsIDAsIDAsIDEsIDAsIDBdLFxuICAyOiB3aWR0aCA9PiBbLTEsIDAsIDAsIDEsIHdpZHRoLCAwXSxcbiAgMzogKHdpZHRoLCBoZWlnaHQpID0+IFstMSwgMCwgMCwgLTEsIHdpZHRoLCBoZWlnaHRdLFxuICA0OiAod2lkdGgsIGhlaWdodCkgPT4gWzEsIDAsIDAsIC0xLCAwLCBoZWlnaHRdLFxuICA1OiAoKSA9PiBbMCwgMSwgMSwgMCwgMCwgMF0sXG4gIDY6ICh3aWR0aCwgaGVpZ2h0KSA9PiBbMCwgMSwgLTEsIDAsIGhlaWdodCwgMF0sXG4gIDc6ICh3aWR0aCwgaGVpZ2h0KSA9PiBbMCwgLTEsIC0xLCAwLCBoZWlnaHQsIHdpZHRoXSxcbiAgODogd2lkdGggPT4gWzAsIC0xLCAxLCAwLCAwLCB3aWR0aF1cbn07XG5cbmNvbnN0IGZpeEltYWdlT3JpZW50YXRpb24gPSAoY3R4LCB3aWR0aCwgaGVpZ2h0LCBvcmllbnRhdGlvbikgPT4ge1xuICAvLyBubyBvcmllbnRhdGlvbiBzdXBwbGllZFxuICBpZiAob3JpZW50YXRpb24gPT09IC0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRyYW5zZm9ybXNbb3JpZW50YXRpb25dKHdpZHRoLCBoZWlnaHQpKTtcbn07XG5cbi8vIGRyYXdzIHRoZSBwcmV2aWV3IGltYWdlIHRvIGNhbnZhc1xuY29uc3QgY3JlYXRlUHJldmlld0ltYWdlID0gKGRhdGEsIHdpZHRoLCBoZWlnaHQsIG9yaWVudGF0aW9uKSA9PiB7XG4gIC8vIGNhbid0IGRyYXcgb24gaGFsZiBwaXhlbHNcbiAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuXG4gIC8vIGRyYXcgaW1hZ2VcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAvLyBpZiBpcyByb3RhdGVkIGluY29ycmVjdGx5IHN3YXAgd2lkdGggYW5kIGhlaWdodFxuICBpZiAob3JpZW50YXRpb24gPj0gNSAmJiBvcmllbnRhdGlvbiA8PSA4KSB7XG4gICAgW3dpZHRoLCBoZWlnaHRdID0gW2hlaWdodCwgd2lkdGhdO1xuICB9XG5cbiAgLy8gY29ycmVjdCBpbWFnZSBvcmllbnRhdGlvblxuICBmaXhJbWFnZU9yaWVudGF0aW9uKGN0eCwgd2lkdGgsIGhlaWdodCwgb3JpZW50YXRpb24pO1xuXG4gIC8vIGRyYXcgdGhlIGltYWdlXG4gIGN0eC5kcmF3SW1hZ2UoZGF0YSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgcmV0dXJuIGNhbnZhcztcbn07XG5cbmNvbnN0IGlzQml0bWFwID0gZmlsZSA9PiAvXmltYWdlLy50ZXN0KGZpbGUudHlwZSkgJiYgIS9zdmcvLnRlc3QoZmlsZS50eXBlKTtcblxuY29uc3QgTUFYX1dJRFRIID0gMTA7XG5jb25zdCBNQVhfSEVJR0hUID0gMTA7XG5cbmNvbnN0IGNhbGN1bGF0ZUF2ZXJhZ2VDb2xvciA9IGltYWdlID0+IHtcbiAgY29uc3Qgc2NhbGFyID0gTWF0aC5taW4oTUFYX1dJRFRIIC8gaW1hZ2Uud2lkdGgsIE1BWF9IRUlHSFQgLyBpbWFnZS5oZWlnaHQpO1xuXG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY29uc3Qgd2lkdGggPSAoY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKGltYWdlLndpZHRoICogc2NhbGFyKSk7XG4gIGNvbnN0IGhlaWdodCA9IChjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGltYWdlLmhlaWdodCAqIHNjYWxhcikpO1xuICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgbGV0IGRhdGEgPSBudWxsO1xuICB0cnkge1xuICAgIGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsID0gZGF0YS5sZW5ndGg7XG5cbiAgbGV0IHIgPSAwO1xuICBsZXQgZyA9IDA7XG4gIGxldCBiID0gMDtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgciArPSBkYXRhW2ldICogZGF0YVtpXTtcbiAgICBnICs9IGRhdGFbaSArIDFdICogZGF0YVtpICsgMV07XG4gICAgYiArPSBkYXRhW2kgKyAyXSAqIGRhdGFbaSArIDJdO1xuICB9XG5cbiAgciA9IGF2ZXJhZ2VDb2xvcihyLCBsKTtcbiAgZyA9IGF2ZXJhZ2VDb2xvcihnLCBsKTtcbiAgYiA9IGF2ZXJhZ2VDb2xvcihiLCBsKTtcblxuICByZXR1cm4geyByLCBnLCBiIH07XG59O1xuXG5jb25zdCBhdmVyYWdlQ29sb3IgPSAoYywgbCkgPT4gTWF0aC5mbG9vcihNYXRoLnNxcnQoYyAvIChsIC8gNCkpKTtcblxuY29uc3QgY2xvbmVDYW52YXMgPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICB0YXJnZXQud2lkdGggPSBvcmlnaW4ud2lkdGg7XG4gIHRhcmdldC5oZWlnaHQgPSBvcmlnaW4uaGVpZ2h0O1xuICBjb25zdCBjdHggPSB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LmRyYXdJbWFnZShvcmlnaW4sIDAsIDApO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuY29uc3QgY2xvbmVJbWFnZURhdGEgPSBpbWFnZURhdGEgPT4ge1xuICBsZXQgaWQ7XG4gIHRyeSB7XG4gICAgaWQgPSBuZXcgSW1hZ2VEYXRhKGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZCA9IGN0eC5jcmVhdGVJbWFnZURhdGEoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcbiAgfVxuICBpZC5kYXRhLnNldChuZXcgVWludDhDbGFtcGVkQXJyYXkoaW1hZ2VEYXRhLmRhdGEpKTtcbiAgcmV0dXJuIGlkO1xufTtcblxuY29uc3QgbG9hZEltYWdlID0gdXJsID0+XG4gIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZShpbWcpO1xuICAgIH07XG4gICAgaW1nLm9uZXJyb3IgPSBlID0+IHtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9O1xuICAgIGltZy5zcmMgPSB1cmw7XG4gIH0pO1xuXG5jb25zdCBjcmVhdGVJbWFnZVdyYXBwZXJWaWV3ID0gXyA9PiB7XG4gIC8vIGNyZWF0ZSBvdmVybGF5IHZpZXdcbiAgY29uc3QgT3ZlcmxheVZpZXcgPSBjcmVhdGVJbWFnZU92ZXJsYXlWaWV3KF8pO1xuXG4gIGNvbnN0IEltYWdlVmlldyA9IGNyZWF0ZUltYWdlVmlldyhfKTtcblxuICBjb25zdCB7IGNyZWF0ZVdvcmtlciB9ID0gXy51dGlscztcblxuICBjb25zdCBhcHBseUZpbHRlciA9IChyb290LCBmaWx0ZXIsIHRhcmdldCkgPT5cbiAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIC8vIHdpbGwgc3RvcmUgaW1hZ2UgZGF0YSBmb3IgZnV0dXJlIGZpbHRlciB1cGRhdGVzXG4gICAgICBpZiAoIXJvb3QucmVmLmltYWdlRGF0YSkge1xuICAgICAgICByb290LnJlZi5pbWFnZURhdGEgPSB0YXJnZXRcbiAgICAgICAgICAuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgIC5nZXRJbWFnZURhdGEoMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGltYWdlIGRhdGEgcmVmZXJlbmNlXG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjbG9uZUltYWdlRGF0YShyb290LnJlZi5pbWFnZURhdGEpO1xuXG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIubGVuZ3RoICE9PSAyMCkge1xuICAgICAgICB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd29ya2VyID0gY3JlYXRlV29ya2VyKENvbG9yTWF0cml4V29ya2VyKTtcbiAgICAgIHdvcmtlci5wb3N0KFxuICAgICAgICB7XG4gICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgIGNvbG9yTWF0cml4OiBmaWx0ZXJcbiAgICAgICAgfSxcbiAgICAgICAgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgIC8vIGFwcGx5IGZpbHRlcmVkIGNvbG9yc1xuICAgICAgICAgIHRhcmdldC5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShyZXNwb25zZSwgMCwgMCk7XG5cbiAgICAgICAgICAvLyBzdG9wIHdvcmtlclxuICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcblxuICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBbaW1hZ2VEYXRhLmRhdGEuYnVmZmVyXVxuICAgICAgKTtcbiAgICB9KTtcblxuICBjb25zdCByZW1vdmVJbWFnZVZpZXcgPSAocm9vdCwgaW1hZ2VWaWV3KSA9PiB7XG4gICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcoaW1hZ2VWaWV3KTtcbiAgICBpbWFnZVZpZXcuaW1hZ2Uud2lkdGggPSAxO1xuICAgIGltYWdlVmlldy5pbWFnZS5oZWlnaHQgPSAxO1xuICAgIGltYWdlVmlldy5fZGVzdHJveSgpO1xuICB9O1xuXG4gIC8vIHJlbW92ZSBhbiBpbWFnZVxuICBjb25zdCBzaGlmdEltYWdlID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgY29uc3QgaW1hZ2VWaWV3ID0gcm9vdC5yZWYuaW1hZ2VzLnNoaWZ0KCk7XG4gICAgaW1hZ2VWaWV3Lm9wYWNpdHkgPSAwO1xuICAgIGltYWdlVmlldy50cmFuc2xhdGVZID0gLTE1O1xuICAgIHJvb3QucmVmLmltYWdlVmlld0Jpbi5wdXNoKGltYWdlVmlldyk7XG4gICAgcmV0dXJuIGltYWdlVmlldztcbiAgfTtcblxuICAvLyBhZGQgbmV3IGltYWdlXG4gIGNvbnN0IHB1c2hJbWFnZSA9ICh7IHJvb3QsIHByb3BzLCBpbWFnZSB9KSA9PiB7XG4gICAgY29uc3QgaWQgPSBwcm9wcy5pZDtcbiAgICBjb25zdCBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCB7IGlkIH0pO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgY29uc3QgY3JvcCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKSB8fCB7XG4gICAgICBjZW50ZXI6IHtcbiAgICAgICAgeDogMC41LFxuICAgICAgICB5OiAwLjVcbiAgICAgIH0sXG4gICAgICBmbGlwOiB7XG4gICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICB2ZXJ0aWNhbDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB6b29tOiAxLFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICBhc3BlY3RSYXRpbzogbnVsbFxuICAgIH07XG5cbiAgICBjb25zdCBiYWNrZ3JvdW5kID0gcm9vdC5xdWVyeShcbiAgICAgICdHRVRfSU1BR0VfVFJBTlNGT1JNX0NBTlZBU19CQUNLR1JPVU5EX0NPTE9SJ1xuICAgICk7XG5cbiAgICBsZXQgbWFya3VwO1xuICAgIGxldCByZXNpemU7XG4gICAgbGV0IGRpcnR5ID0gZmFsc2U7XG4gICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01BUktVUF9TSE9XJykpIHtcbiAgICAgIG1hcmt1cCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ21hcmt1cCcpIHx8IFtdO1xuICAgICAgcmVzaXplID0gaXRlbS5nZXRNZXRhZGF0YSgncmVzaXplJyk7XG4gICAgICBkaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIGltYWdlIHByZXNlbnRlclxuICAgIGNvbnN0IGltYWdlVmlldyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoSW1hZ2VWaWV3LCB7XG4gICAgICAgIGlkLFxuICAgICAgICBpbWFnZSxcbiAgICAgICAgY3JvcCxcbiAgICAgICAgcmVzaXplLFxuICAgICAgICBtYXJrdXAsXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBiYWNrZ3JvdW5kLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBzY2FsZVg6IDEuMTUsXG4gICAgICAgIHNjYWxlWTogMS4xNSxcbiAgICAgICAgdHJhbnNsYXRlWTogMTVcbiAgICAgIH0pLFxuICAgICAgcm9vdC5jaGlsZFZpZXdzLmxlbmd0aFxuICAgICk7XG4gICAgcm9vdC5yZWYuaW1hZ2VzLnB1c2goaW1hZ2VWaWV3KTtcblxuICAgIC8vIHJldmVhbCB0aGUgcHJldmlldyBpbWFnZVxuICAgIGltYWdlVmlldy5vcGFjaXR5ID0gMTtcbiAgICBpbWFnZVZpZXcuc2NhbGVYID0gMTtcbiAgICBpbWFnZVZpZXcuc2NhbGVZID0gMTtcbiAgICBpbWFnZVZpZXcudHJhbnNsYXRlWSA9IDA7XG5cbiAgICAvLyB0aGUgcHJldmlldyBpcyBub3cgcmVhZHkgdG8gYmUgZHJhd25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9JTUFHRV9QUkVWSUVXX1NIT1cnLCB7IGlkIH0pO1xuICAgIH0sIDI1MCk7XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlSW1hZ2UgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgeyBpZDogcHJvcHMuaWQgfSk7XG4gICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgY29uc3QgaW1hZ2VWaWV3ID0gcm9vdC5yZWYuaW1hZ2VzW3Jvb3QucmVmLmltYWdlcy5sZW5ndGggLSAxXTtcbiAgICBpbWFnZVZpZXcuY3JvcCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKTtcbiAgICBpbWFnZVZpZXcuYmFja2dyb3VuZCA9IHJvb3QucXVlcnkoXG4gICAgICAnR0VUX0lNQUdFX1RSQU5TRk9STV9DQU5WQVNfQkFDS0dST1VORF9DT0xPUidcbiAgICApO1xuICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVJLVVBfU0hPVycpKSB7XG4gICAgICBpbWFnZVZpZXcuZGlydHkgPSB0cnVlO1xuICAgICAgaW1hZ2VWaWV3LnJlc2l6ZSA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ3Jlc2l6ZScpO1xuICAgICAgaW1hZ2VWaWV3Lm1hcmt1cCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ21hcmt1cCcpO1xuICAgIH1cbiAgfTtcblxuICAvLyByZXBsYWNlIGltYWdlIHByZXZpZXdcbiAgY29uc3QgZGlkVXBkYXRlSXRlbU1ldGFkYXRhID0gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbiB9KSA9PiB7XG4gICAgLy8gb25seSBmaWx0ZXIgYW5kIGNyb3AgdHJpZ2dlciByZWRyYXdcbiAgICBpZiAoIS9jcm9wfGZpbHRlcnxtYXJrdXB8cmVzaXplLy50ZXN0KGFjdGlvbi5jaGFuZ2Uua2V5KSkgcmV0dXJuO1xuXG4gICAgLy8gbm8gaW1hZ2VzIHRvIHVwZGF0ZSwgZXhpdFxuICAgIGlmICghcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgLy8gbm8gaXRlbSBmb3VuZCwgZXhpdFxuICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgLy8gZm9yIG5vdywgdXBkYXRlIGV4aXN0aW5nIGltYWdlIHdoZW4gZmlsdGVyaW5nXG4gICAgaWYgKC9maWx0ZXIvLnRlc3QoYWN0aW9uLmNoYW5nZS5rZXkpKSB7XG4gICAgICBjb25zdCBpbWFnZVZpZXcgPSByb290LnJlZi5pbWFnZXNbcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgYXBwbHlGaWx0ZXIocm9vdCwgYWN0aW9uLmNoYW5nZS52YWx1ZSwgaW1hZ2VWaWV3LmltYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoL2Nyb3B8bWFya3VwfHJlc2l6ZS8udGVzdChhY3Rpb24uY2hhbmdlLmtleSkpIHtcbiAgICAgIGNvbnN0IGNyb3AgPSBpdGVtLmdldE1ldGFkYXRhKCdjcm9wJyk7XG4gICAgICBjb25zdCBpbWFnZSA9IHJvb3QucmVmLmltYWdlc1tyb290LnJlZi5pbWFnZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIC8vIGlmIGFzcGVjdCByYXRpbyBoYXMgY2hhbmdlZCwgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgaW1hZ2VcbiAgICAgIGlmIChcbiAgICAgICAgY3JvcCAmJlxuICAgICAgICBjcm9wLmFzcGVjdFJhdGlvICYmXG4gICAgICAgIGltYWdlLmNyb3AgJiZcbiAgICAgICAgaW1hZ2UuY3JvcC5hc3BlY3RSYXRpbyAmJlxuICAgICAgICBNYXRoLmFicyhjcm9wLmFzcGVjdFJhdGlvIC0gaW1hZ2UuY3JvcC5hc3BlY3RSYXRpbykgPiAwLjAwMDAxXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgaW1hZ2VWaWV3ID0gc2hpZnRJbWFnZSh7IHJvb3QgfSk7XG4gICAgICAgIHB1c2hJbWFnZSh7IHJvb3QsIHByb3BzLCBpbWFnZTogY2xvbmVDYW52YXMoaW1hZ2VWaWV3LmltYWdlKSB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIG5vdCwgd2UgY2FuIHVwZGF0ZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAgZWxzZSB7XG4gICAgICAgIHVwZGF0ZUltYWdlKHsgcm9vdCwgcHJvcHMgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNhbkNyZWF0ZUltYWdlQml0bWFwID0gZmlsZSA9PiB7XG4gICAgLy8gRmlyZWZveCB2ZXJzaW9ucyBiZWZvcmUgNTggd2lsbCBmcmVlemUgd2hlbiBydW5uaW5nIGNyZWF0ZUltYWdlQml0bWFwXG4gICAgLy8gaW4gYSBXZWIgV29ya2VyIHNvIHdlIGRldGVjdCB0aG9zZSB2ZXJzaW9ucyBhbmQgcmV0dXJuIGZhbHNlIGZvciBzdXBwb3J0XG4gICAgY29uc3QgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgaXNGaXJlZm94ID0gdXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFswLTldKylcXC4vKTtcbiAgICBjb25zdCBmaXJlZm94VmVyc2lvbiA9IGlzRmlyZWZveCA/IHBhcnNlSW50KGlzRmlyZWZveFsxXSkgOiBudWxsO1xuICAgIGlmIChmaXJlZm94VmVyc2lvbiAhPT0gbnVsbCAmJiBmaXJlZm94VmVyc2lvbiA8PSA1OCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuICdjcmVhdGVJbWFnZUJpdG1hcCcgaW4gd2luZG93ICYmIGlzQml0bWFwKGZpbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcml0ZSBoYW5kbGVyIGZvciB3aGVuIHByZXZpZXcgY29udGFpbmVyIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICovXG4gIGNvbnN0IGRpZENyZWF0ZVByZXZpZXdDb250YWluZXIgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgeyBpZCB9ID0gcHJvcHM7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIGdldCB0aGUgZmlsZSBkYXRhIHRvIGRldGVybWluZSB0aGUgZXZlbnR1YWwgaW1hZ2Ugc2l6ZVxuICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGlkKTtcbiAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgIC8vIGdldCB1cmwgdG8gZmlsZSAod2UnbGwgcmV2b2tlIGl0IGxhdGVyIG9uIHdoZW4gZG9uZSlcbiAgICBjb25zdCBmaWxlVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpdGVtLmZpbGUpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGltYWdlIHNpemUgb2YgdGhpcyBpdGVtXG4gICAgZ2V0SW1hZ2VTaXplKGZpbGVVUkwsICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICAvLyB3ZSBjYW4gbm93IHNjYWxlIHRoZSBwYW5lbCB0byB0aGUgZmluYWwgc2l6ZVxuICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0lNQUdFX1BSRVZJRVdfQ0FMQ1VMQVRFX1NJWkUnLCB7XG4gICAgICAgIGlkLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBkcmF3UHJldmlldyA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICBjb25zdCB7IGlkIH0gPSBwcm9wcztcblxuICAgIC8vIHdlIG5lZWQgdG8gZ2V0IHRoZSBmaWxlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoZSBldmVudHVhbCBpbWFnZSBzaXplXG4gICAgY29uc3QgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgaWQpO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgLy8gZ2V0IHVybCB0byBmaWxlICh3ZSdsbCByZXZva2UgaXQgbGF0ZXIgb24gd2hlbiBkb25lKVxuICAgIGNvbnN0IGZpbGVVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGl0ZW0uZmlsZSk7XG5cbiAgICAvLyBmYWxsYmFja1xuICAgIGNvbnN0IGxvYWRQcmV2aWV3RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAvLyBsZXQncyBzY2FsZSB0aGUgaW1hZ2UgaW4gdGhlIG1haW4gdGhyZWFkIDooXG4gICAgICBsb2FkSW1hZ2UoZmlsZVVSTCkudGhlbihwcmV2aWV3SW1hZ2VMb2FkZWQpO1xuICAgIH07XG5cbiAgICAvLyBpbWFnZSBpcyBub3cgcmVhZHlcbiAgICBjb25zdCBwcmV2aWV3SW1hZ2VMb2FkZWQgPSBpbWFnZURhdGEgPT4ge1xuICAgICAgLy8gdGhlIGZpbGUgdXJsIGlzIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZmlsZVVSTCk7XG5cbiAgICAgIC8vIGRyYXcgdGhlIHNjYWxlZCBkb3duIHZlcnNpb24gaGVyZSBhbmQgdXNlIHRoYXQgYXMgc291cmNlIHNvIGJpdG1hcGRhdGEgY2FuIGJlIGNsb3NlZFxuICAgICAgLy8gb3JpZW50YXRpb24gaW5mb1xuICAgICAgY29uc3QgZXhpZiA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2V4aWYnKSB8fCB7fTtcbiAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gZXhpZi5vcmllbnRhdGlvbiB8fCAtMTtcblxuICAgICAgLy8gZ2V0IHdpZHRoIGFuZCBoZWlnaHQgZnJvbSBhY3Rpb24sIGFuZCBzd2FwIGlmIG9yaWVudGF0aW9uIGlzIGluY29ycmVjdFxuICAgICAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2VEYXRhO1xuXG4gICAgICAvLyBpZiBubyB3aWR0aCBvciBoZWlnaHQsIGp1c3QgcmV0dXJuIGVhcmx5LlxuICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSByZXR1cm47XG5cbiAgICAgIGlmIChvcmllbnRhdGlvbiA+PSA1ICYmIG9yaWVudGF0aW9uIDw9IDgpIHtcbiAgICAgICAgW3dpZHRoLCBoZWlnaHRdID0gW2hlaWdodCwgd2lkdGhdO1xuICAgICAgfVxuXG4gICAgICAvLyBzY2FsZSBjYW52YXMgYmFzZWQgb24gcGl4ZWwgZGVuc2l0eVxuICAgICAgLy8gd2UgbXVsdGlwbHkgYnkgLjc1IGFzIHRoYXQgY3JlYXRlcyBzbWFsbGVyIGJ1dCBzdGlsbCBjbGVhciBpbWFnZXMgb24gc2NyZWVucyB3aXRoIGhpZ2ggcmVzIGRpc3BsYXlzXG4gICAgICBjb25zdCBwaXhlbERlbnNpdHlGYWN0b3IgPSBNYXRoLm1heCgxLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAqIDAuNzUpO1xuXG4gICAgICAvLyB3ZSB3YW50IGFzIG11Y2ggcGl4ZWxzIHRvIHdvcmsgd2l0aCBhcyBwb3NzaWJsZSxcbiAgICAgIC8vIHRoaXMgbXVsdGlwbGllcyB0aGUgbWluaW11bSBpbWFnZSByZXNvbHV0aW9uLFxuICAgICAgLy8gc28gd2hlbiB6b29taW5nIGluIGl0IGRvZXNuJ3QgZ2V0IHRvbyBibHVycnlcbiAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19aT09NX0ZBQ1RPUicpO1xuXG4gICAgICAvLyBpbWFlZyBzY2FsZSBmYWN0b3JcbiAgICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gem9vbUZhY3RvciAqIHBpeGVsRGVuc2l0eUZhY3RvcjtcblxuICAgICAgLy8gY2FsY3VsYXRlIHNjYWxlZCBwcmV2aWV3IGltYWdlIHNpemVcbiAgICAgIGNvbnN0IHByZXZpZXdJbWFnZVJhdGlvID0gaGVpZ2h0IC8gd2lkdGg7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBpbWFnZSBwcmV2aWV3IGhlaWdodCBhbmQgd2lkdGhcbiAgICAgIGNvbnN0IHByZXZpZXdDb250YWluZXJXaWR0aCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgY29uc3QgcHJldmlld0NvbnRhaW5lckhlaWdodCA9IHJvb3QucmVjdC5lbGVtZW50LmhlaWdodDtcblxuICAgICAgbGV0IGltYWdlV2lkdGggPSBwcmV2aWV3Q29udGFpbmVyV2lkdGg7XG4gICAgICBsZXQgaW1hZ2VIZWlnaHQgPSBpbWFnZVdpZHRoICogcHJldmlld0ltYWdlUmF0aW87XG5cbiAgICAgIGlmIChwcmV2aWV3SW1hZ2VSYXRpbyA+IDEpIHtcbiAgICAgICAgaW1hZ2VXaWR0aCA9IE1hdGgubWluKHdpZHRoLCBwcmV2aWV3Q29udGFpbmVyV2lkdGggKiBzY2FsZUZhY3Rvcik7XG4gICAgICAgIGltYWdlSGVpZ2h0ID0gaW1hZ2VXaWR0aCAqIHByZXZpZXdJbWFnZVJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2VIZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIHByZXZpZXdDb250YWluZXJIZWlnaHQgKiBzY2FsZUZhY3Rvcik7XG4gICAgICAgIGltYWdlV2lkdGggPSBpbWFnZUhlaWdodCAvIHByZXZpZXdJbWFnZVJhdGlvO1xuICAgICAgfVxuXG4gICAgICAvLyB0cmFuc2ZlciB0byBpbWFnZSB0YWcgc28gbm8gY2FudmFzIG1lbW9yeSB3YXN0ZWQgb24gaU9TXG4gICAgICBjb25zdCBwcmV2aWV3SW1hZ2UgPSBjcmVhdGVQcmV2aWV3SW1hZ2UoXG4gICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgaW1hZ2VXaWR0aCxcbiAgICAgICAgaW1hZ2VIZWlnaHQsXG4gICAgICAgIG9yaWVudGF0aW9uXG4gICAgICApO1xuXG4gICAgICAvLyBkb25lXG4gICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAvLyBjYWxjdWxhdGUgYXZlcmFnZSBpbWFnZSBjb2xvciwgZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICBjb25zdCBhdmVyYWdlQ29sb3IgPSByb290LnF1ZXJ5KFxuICAgICAgICAgICdHRVRfSU1BR0VfUFJFVklFV19DQUxDVUxBVEVfQVZFUkFHRV9JTUFHRV9DT0xPUidcbiAgICAgICAgKVxuICAgICAgICAgID8gY2FsY3VsYXRlQXZlcmFnZUNvbG9yKGRhdGEpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBpdGVtLnNldE1ldGFkYXRhKCdjb2xvcicsIGF2ZXJhZ2VDb2xvciwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gZGF0YSBoYXMgYmVlbiB0cmFuc2ZlcnJlZCB0byBjYW52YXMgKCBpZiB3YXMgSW1hZ2VCaXRtYXAgKVxuICAgICAgICBpZiAoJ2Nsb3NlJyBpbiBpbWFnZURhdGEpIHtcbiAgICAgICAgICBpbWFnZURhdGEuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3cgdGhlIG92ZXJsYXlcbiAgICAgICAgcm9vdC5yZWYub3ZlcmxheVNoYWRvdy5vcGFjaXR5ID0gMTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGZpcnN0IGltYWdlXG4gICAgICAgIHB1c2hJbWFnZSh7IHJvb3QsIHByb3BzLCBpbWFnZTogcHJldmlld0ltYWdlIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gYXBwbHkgZmlsdGVyXG4gICAgICBjb25zdCBmaWx0ZXIgPSBpdGVtLmdldE1ldGFkYXRhKCdmaWx0ZXInKTtcbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgYXBwbHlGaWx0ZXIocm9vdCwgZmlsdGVyLCBwcmV2aWV3SW1hZ2UpLnRoZW4oZG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGlmIHdlIHN1cHBvcnQgc2NhbGluZyB1c2luZyBjcmVhdGVJbWFnZUJpdG1hcCB3ZSB1c2UgYSB3b3JrZXJcbiAgICBpZiAoY2FuQ3JlYXRlSW1hZ2VCaXRtYXAoaXRlbS5maWxlKSkge1xuICAgICAgLy8gbGV0J3Mgc2NhbGUgdGhlIGltYWdlIGluIGEgd29ya2VyXG4gICAgICBjb25zdCB3b3JrZXIgPSBjcmVhdGVXb3JrZXIoQml0bWFwV29ya2VyKTtcblxuICAgICAgd29ya2VyLnBvc3QoXG4gICAgICAgIHtcbiAgICAgICAgICBmaWxlOiBpdGVtLmZpbGVcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VCaXRtYXAgPT4ge1xuICAgICAgICAgIC8vIGRlc3Ryb3kgd29ya2VyXG4gICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuXG4gICAgICAgICAgLy8gbm8gYml0bWFwIHJldHVybmVkLCBtdXN0IGJlIHNvbWV0aGluZyB3cm9uZyxcbiAgICAgICAgICAvLyB0cnkgdGhlIG9sZHNjaG9vbCB3YXlcbiAgICAgICAgICBpZiAoIWltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICBsb2FkUHJldmlld0ZhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8geWF5IHdlIGdvdCBvdXIgYml0bWFwLCBsZXQncyBjb250aW51ZSBzaG93aW5nIHRoZSBwcmV2aWV3XG4gICAgICAgICAgcHJldmlld0ltYWdlTG9hZGVkKGltYWdlQml0bWFwKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGZhbGxiYWNrIHByZXZpZXdcbiAgICAgIGxvYWRQcmV2aWV3RmFsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdyaXRlIGhhbmRsZXIgZm9yIHdoZW4gdGhlIHByZXZpZXcgaW1hZ2UgaXMgcmVhZHkgdG8gYmUgYW5pbWF0ZWRcbiAgICovXG4gIGNvbnN0IGRpZERyYXdQcmV2aWV3ID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgLy8gZ2V0IGxhc3QgYWRkZWQgaW1hZ2VcbiAgICBjb25zdCBpbWFnZSA9IHJvb3QucmVmLmltYWdlc1tyb290LnJlZi5pbWFnZXMubGVuZ3RoIC0gMV07XG4gICAgaW1hZ2UudHJhbnNsYXRlWSA9IDA7XG4gICAgaW1hZ2Uuc2NhbGVYID0gMS4wO1xuICAgIGltYWdlLnNjYWxlWSA9IDEuMDtcbiAgICBpbWFnZS5vcGFjaXR5ID0gMTtcbiAgfTtcblxuICAvKipcbiAgICogV3JpdGUgaGFuZGxlciBmb3Igd2hlbiB0aGUgcHJldmlldyBoYXMgYmVlbiBsb2FkZWRcbiAgICovXG4gIGNvbnN0IHJlc3RvcmVPdmVybGF5ID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgcm9vdC5yZWYub3ZlcmxheVNoYWRvdy5vcGFjaXR5ID0gMTtcbiAgICByb290LnJlZi5vdmVybGF5RXJyb3Iub3BhY2l0eSA9IDA7XG4gICAgcm9vdC5yZWYub3ZlcmxheVN1Y2Nlc3Mub3BhY2l0eSA9IDA7XG4gIH07XG5cbiAgY29uc3QgZGlkVGhyb3dFcnJvciA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIHJvb3QucmVmLm92ZXJsYXlTaGFkb3cub3BhY2l0eSA9IDAuMjU7XG4gICAgcm9vdC5yZWYub3ZlcmxheUVycm9yLm9wYWNpdHkgPSAxO1xuICB9O1xuXG4gIGNvbnN0IGRpZENvbXBsZXRlUHJvY2Vzc2luZyA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIHJvb3QucmVmLm92ZXJsYXlTaGFkb3cub3BhY2l0eSA9IDAuMjU7XG4gICAgcm9vdC5yZWYub3ZlcmxheVN1Y2Nlc3Mub3BhY2l0eSA9IDE7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdCBjcmVhdGUgPSAoeyByb290IH0pID0+IHtcbiAgICAvLyBpbWFnZSB2aWV3XG4gICAgcm9vdC5yZWYuaW1hZ2VzID0gW107XG5cbiAgICAvLyB0aGUgcHJldmlldyBpbWFnZSBkYXRhICh3ZSBuZWVkIHRoaXMgdG8gZmlsdGVyIHRoZSBpbWFnZSlcbiAgICByb290LnJlZi5pbWFnZURhdGEgPSBudWxsO1xuXG4gICAgLy8gaW1hZ2UgYmluXG4gICAgcm9vdC5yZWYuaW1hZ2VWaWV3QmluID0gW107XG5cbiAgICAvLyBpbWFnZSBvdmVybGF5c1xuICAgIHJvb3QucmVmLm92ZXJsYXlTaGFkb3cgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KE92ZXJsYXlWaWV3LCB7XG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHN0YXR1czogJ2lkbGUnXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByb290LnJlZi5vdmVybGF5U3VjY2VzcyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoT3ZlcmxheVZpZXcsIHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgc3RhdHVzOiAnc3VjY2VzcydcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJvb3QucmVmLm92ZXJsYXlFcnJvciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoT3ZlcmxheVZpZXcsIHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgc3RhdHVzOiAnZmFpbHVyZSdcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gXy51dGlscy5jcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnaW1hZ2UtcHJldmlldy13cmFwcGVyJyxcbiAgICBjcmVhdGUsXG4gICAgc3R5bGVzOiBbJ2hlaWdodCddLFxuICAgIGFwaXM6IFsnaGVpZ2h0J10sXG4gICAgZGVzdHJveTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAvLyB3ZSByZXNpemUgdGhlIGltYWdlIHNvIG1lbW9yeSBvbiBpT1MgMTIgaXMgcmVsZWFzZWQgbW9yZSBxdWlja2x5IChpdCBzZWVtcylcbiAgICAgIHJvb3QucmVmLmltYWdlcy5mb3JFYWNoKGltYWdlVmlldyA9PiB7XG4gICAgICAgIGltYWdlVmlldy5pbWFnZS53aWR0aCA9IDE7XG4gICAgICAgIGltYWdlVmlldy5pbWFnZS5oZWlnaHQgPSAxO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkaWRXcml0ZVZpZXc6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgcm9vdC5yZWYuaW1hZ2VzLmZvckVhY2goaW1hZ2VWaWV3ID0+IHtcbiAgICAgICAgaW1hZ2VWaWV3LmRpcnR5ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHdyaXRlOiBfLnV0aWxzLmNyZWF0ZVJvdXRlKFxuICAgICAge1xuICAgICAgICAvLyBpbWFnZSBwcmV2aWV3IHN0YXRlZFxuICAgICAgICBESURfSU1BR0VfUFJFVklFV19EUkFXOiBkaWREcmF3UHJldmlldyxcbiAgICAgICAgRElEX0lNQUdFX1BSRVZJRVdfQ09OVEFJTkVSX0NSRUFURTogZGlkQ3JlYXRlUHJldmlld0NvbnRhaW5lcixcbiAgICAgICAgRElEX0ZJTklTSF9DQUxDVUxBVEVfUFJFVklFV1NJWkU6IGRyYXdQcmV2aWV3LFxuICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6IGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YSxcblxuICAgICAgICAvLyBmaWxlIHN0YXRlc1xuICAgICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBkaWRUaHJvd0Vycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBkaWRUaHJvd0Vycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiBkaWRUaHJvd0Vycm9yLFxuICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBkaWRDb21wbGV0ZVByb2Nlc3NpbmcsXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IHJlc3RvcmVPdmVybGF5LFxuICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogcmVzdG9yZU92ZXJsYXlcbiAgICAgIH0sXG4gICAgICAoeyByb290IH0pID0+IHtcbiAgICAgICAgLy8gdmlld3Mgb24gZGVhdGggcm93XG4gICAgICAgIGNvbnN0IHZpZXdzVG9SZW1vdmUgPSByb290LnJlZi5pbWFnZVZpZXdCaW4uZmlsdGVyKFxuICAgICAgICAgIGltYWdlVmlldyA9PiBpbWFnZVZpZXcub3BhY2l0eSA9PT0gMFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHZpZXdzIHRvIHJldGFpblxuICAgICAgICByb290LnJlZi5pbWFnZVZpZXdCaW4gPSByb290LnJlZi5pbWFnZVZpZXdCaW4uZmlsdGVyKFxuICAgICAgICAgIGltYWdlVmlldyA9PiBpbWFnZVZpZXcub3BhY2l0eSA+IDBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlc2Ugdmlld3NcbiAgICAgICAgdmlld3NUb1JlbW92ZS5mb3JFYWNoKGltYWdlVmlldyA9PiByZW1vdmVJbWFnZVZpZXcocm9vdCwgaW1hZ2VWaWV3KSk7XG4gICAgICAgIHZpZXdzVG9SZW1vdmUubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICApXG4gIH0pO1xufTtcblxuLyoqXG4gKiBJbWFnZSBQcmV2aWV3IFBsdWdpblxuICovXG5jb25zdCBwbHVnaW4gPSBmcEFQSSA9PiB7XG4gIGNvbnN0IHsgYWRkRmlsdGVyLCB1dGlscyB9ID0gZnBBUEk7XG4gIGNvbnN0IHsgVHlwZSwgY3JlYXRlUm91dGUsIGlzRmlsZSB9ID0gdXRpbHM7XG5cbiAgLy8gaW1hZ2VQcmV2aWV3Vmlld1xuICBjb25zdCBpbWFnZVByZXZpZXdWaWV3ID0gY3JlYXRlSW1hZ2VXcmFwcGVyVmlldyhmcEFQSSk7XG5cbiAgLy8gY2FsbGVkIGZvciBlYWNoIHZpZXcgdGhhdCBpcyBjcmVhdGVkIHJpZ2h0IGFmdGVyIHRoZSAnY3JlYXRlJyBtZXRob2RcbiAgYWRkRmlsdGVyKCdDUkVBVEVfVklFVycsIHZpZXdBUEkgPT4ge1xuICAgIC8vIGdldCByZWZlcmVuY2UgdG8gY3JlYXRlZCB2aWV3XG4gICAgY29uc3QgeyBpcywgdmlldywgcXVlcnkgfSA9IHZpZXdBUEk7XG5cbiAgICAvLyBvbmx5IGhvb2sgdXAgdG8gaXRlbSB2aWV3IGFuZCBvbmx5IGlmIGlzIGVuYWJsZWQgZm9yIHRoaXMgY3JvcHBlclxuICAgIGlmICghaXMoJ2ZpbGUnKSB8fCAhcXVlcnkoJ0dFVF9BTExPV19JTUFHRV9QUkVWSUVXJykpIHJldHVybjtcblxuICAgIC8vIGNyZWF0ZSB0aGUgaW1hZ2UgcHJldmlldyBwbHVnaW4sIGJ1dCBvbmx5IGRvIHNvIGlmIHRoZSBpdGVtIGlzIGFuIGltYWdlXG4gICAgY29uc3QgZGlkTG9hZEl0ZW0gPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICBjb25zdCB7IGlkIH0gPSBwcm9wcztcbiAgICAgIGNvbnN0IGl0ZW0gPSBxdWVyeSgnR0VUX0lURU0nLCBpZCk7XG5cbiAgICAgIC8vIGl0ZW0gY291bGQgdGhlb3JldGljYWxseSBoYXZlIGJlZW4gcmVtb3ZlZCBpbiB0aGUgbWVhbiB0aW1lXG4gICAgICBpZiAoIWl0ZW0gfHwgIWlzRmlsZShpdGVtLmZpbGUpIHx8IGl0ZW0uYXJjaGl2ZWQpIHJldHVybjtcblxuICAgICAgLy8gZ2V0IHRoZSBmaWxlIG9iamVjdFxuICAgICAgY29uc3QgZmlsZSA9IGl0ZW0uZmlsZTtcblxuICAgICAgLy8gZXhpdCBpZiB0aGlzIGlzIG5vdCBhbiBpbWFnZVxuICAgICAgaWYgKCFpc1ByZXZpZXdhYmxlSW1hZ2UoZmlsZSkpIHJldHVybjtcblxuICAgICAgLy8gdGVzdCBpZiBpcyBmaWx0ZXJlZFxuICAgICAgaWYgKCFxdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfRklMVEVSX0lURU0nKShpdGVtKSkgcmV0dXJuO1xuXG4gICAgICAvLyBleGl0IGlmIGltYWdlIHNpemUgaXMgdG9vIGhpZ2ggYW5kIG5vIGNyZWF0ZUltYWdlQml0bWFwIHN1cHBvcnRcbiAgICAgIC8vIHRoaXMgd291bGQgc2ltcGx5IGJyaW5nIHRoZSBicm93c2VyIHRvIGl0cyBrbmVlcyBhbmQgdGhhdCBpcyBub3Qgd2hhdCB3ZSB3YW50XG4gICAgICBjb25zdCBzdXBwb3J0c0NyZWF0ZUltYWdlQml0bWFwID0gJ2NyZWF0ZUltYWdlQml0bWFwJyBpbiAod2luZG93IHx8IHt9KTtcbiAgICAgIGNvbnN0IG1heFByZXZpZXdGaWxlU2l6ZSA9IHF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVhfRklMRV9TSVpFJyk7XG4gICAgICBpZiAoXG4gICAgICAgICFzdXBwb3J0c0NyZWF0ZUltYWdlQml0bWFwICYmXG4gICAgICAgIChtYXhQcmV2aWV3RmlsZVNpemUgJiYgZmlsZS5zaXplID4gbWF4UHJldmlld0ZpbGVTaXplKVxuICAgICAgKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIHNldCBwcmV2aWV3IHZpZXdcbiAgICAgIHJvb3QucmVmLmltYWdlUHJldmlldyA9IHZpZXcuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICB2aWV3LmNyZWF0ZUNoaWxkVmlldyhpbWFnZVByZXZpZXdWaWV3LCB7IGlkIH0pXG4gICAgICApO1xuXG4gICAgICAvLyB1cGRhdGUgaGVpZ2h0IGlmIGlzIGZpeGVkXG4gICAgICBjb25zdCBmaXhlZFByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19IRUlHSFQnKTtcbiAgICAgIGlmIChmaXhlZFByZXZpZXdIZWlnaHQpIHtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1VQREFURV9QQU5FTF9IRUlHSFQnLCB7XG4gICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgaGVpZ2h0OiBmaXhlZFByZXZpZXdIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyByZWFkeVxuICAgICAgY29uc3QgcXVldWUgPVxuICAgICAgICAhc3VwcG9ydHNDcmVhdGVJbWFnZUJpdG1hcCAmJlxuICAgICAgICBmaWxlLnNpemUgPiBxdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFYX0lOU1RBTlRfUFJFVklFV19GSUxFX1NJWkUnKTtcbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9JTUFHRV9QUkVWSUVXX0NPTlRBSU5FUl9DUkVBVEUnLCB7IGlkIH0sIHF1ZXVlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzY2FsZUl0ZW0gPSAocm9vdCwgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcm9vdC5yZWYuaW1hZ2VQcmV2aWV3KSByZXR1cm47XG5cbiAgICAgIGxldCB7IGlkIH0gPSBwcm9wcztcblxuICAgICAgLy8gZ2V0IGl0ZW1cbiAgICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQgfSk7XG4gICAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgICAgLy8gaWYgaXMgZml4ZWQgaGVpZ2h0IG9yIHBhbmVsIGhhcyBhc3BlY3QgcmF0aW8sIGV4aXQgaGVyZSwgaGVpZ2h0IGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZFxuICAgICAgY29uc3QgcGFuZWxBc3BlY3RSYXRpbyA9IHJvb3QucXVlcnkoJ0dFVF9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICAgIGNvbnN0IGl0ZW1QYW5lbEFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICBjb25zdCBmaXhlZEhlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0hFSUdIVCcpO1xuICAgICAgaWYgKHBhbmVsQXNwZWN0UmF0aW8gfHwgaXRlbVBhbmVsQXNwZWN0UmF0aW8gfHwgZml4ZWRIZWlnaHQpIHJldHVybjtcblxuICAgICAgLy8gbm8gZGF0YSFcbiAgICAgIGxldCB7IGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0IH0gPSByb290LnJlZjtcbiAgICAgIGlmICghaW1hZ2VXaWR0aCB8fCAhaW1hZ2VIZWlnaHQpIHJldHVybjtcblxuICAgICAgLy8gZ2V0IGhlaWdodCBtaW4gYW5kIG1heFxuICAgICAgY29uc3QgbWluUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01JTl9IRUlHSFQnKTtcbiAgICAgIGNvbnN0IG1heFByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVhfSEVJR0hUJyk7XG5cbiAgICAgIC8vIG9yaWVudGF0aW9uIGluZm9cbiAgICAgIGNvbnN0IGV4aWYgPSBpdGVtLmdldE1ldGFkYXRhKCdleGlmJykgfHwge307XG4gICAgICBjb25zdCBvcmllbnRhdGlvbiA9IGV4aWYub3JpZW50YXRpb24gfHwgLTE7XG5cbiAgICAgIC8vIGdldCB3aWR0aCBhbmQgaGVpZ2h0IGZyb20gYWN0aW9uLCBhbmQgc3dhcCBvZiBvcmllbnRhdGlvbiBpcyBpbmNvcnJlY3RcbiAgICAgIGlmIChvcmllbnRhdGlvbiA+PSA1ICYmIG9yaWVudGF0aW9uIDw9IDgpXG4gICAgICAgIFtpbWFnZVdpZHRoLCBpbWFnZUhlaWdodF0gPSBbaW1hZ2VIZWlnaHQsIGltYWdlV2lkdGhdO1xuXG4gICAgICAvLyBzY2FsZSB1cCB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gd2UncmUgZGVhbGluZyB3aXRoIGFuIFNWR1xuICAgICAgaWYgKCFpc0JpdG1hcChpdGVtLmZpbGUpIHx8IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX1VQU0NBTEUnKSkge1xuICAgICAgICBjb25zdCBzY2FsYXIgPSAyMDQ4IC8gaW1hZ2VXaWR0aDtcbiAgICAgICAgaW1hZ2VXaWR0aCAqPSBzY2FsYXI7XG4gICAgICAgIGltYWdlSGVpZ2h0ICo9IHNjYWxhcjtcbiAgICAgIH1cblxuICAgICAgLy8gaW1hZ2UgYXNwZWN0IHJhdGlvXG4gICAgICBjb25zdCBpbWFnZUFzcGVjdFJhdGlvID0gaW1hZ2VIZWlnaHQgLyBpbWFnZVdpZHRoO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRoZSBpdGVtIHRvIGdldCB0byB0aGUgY3JvcCBzaXplXG4gICAgICBjb25zdCBwcmV2aWV3QXNwZWN0UmF0aW8gPVxuICAgICAgICAoaXRlbS5nZXRNZXRhZGF0YSgnY3JvcCcpIHx8IHt9KS5hc3BlY3RSYXRpbyB8fCBpbWFnZUFzcGVjdFJhdGlvO1xuXG4gICAgICAvLyBwcmV2aWV3IGhlaWdodCByYW5nZVxuICAgICAgbGV0IHByZXZpZXdIZWlnaHRNYXggPSBNYXRoLm1heChcbiAgICAgICAgbWluUHJldmlld0hlaWdodCxcbiAgICAgICAgTWF0aC5taW4oaW1hZ2VIZWlnaHQsIG1heFByZXZpZXdIZWlnaHQpXG4gICAgICApO1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICBjb25zdCBwcmV2aWV3SGVpZ2h0ID0gTWF0aC5taW4oXG4gICAgICAgIGl0ZW1XaWR0aCAqIHByZXZpZXdBc3BlY3RSYXRpbyxcbiAgICAgICAgcHJldmlld0hlaWdodE1heFxuICAgICAgKTtcblxuICAgICAgLy8gcmVxdWVzdCB1cGRhdGUgdG8gcGFuZWwgaGVpZ2h0XG4gICAgICByb290LmRpc3BhdGNoKCdESURfVVBEQVRFX1BBTkVMX0hFSUdIVCcsIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIGhlaWdodDogcHJldmlld0hlaWdodFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRpZFJlc2l6ZVZpZXcgPSAoeyByb290IH0pID0+IHtcbiAgICAgIC8vIGFjdGlvbnMgaW4gbmV4dCB3cml0ZSBvcGVyYXRpb25cbiAgICAgIHJvb3QucmVmLnNob3VsZFJlc2NhbGUgPSB0cnVlO1xuICAgIH07XG5cbiAgICBjb25zdCBkaWRVcGRhdGVJdGVtTWV0YWRhdGEgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgICAgaWYgKGFjdGlvbi5jaGFuZ2Uua2V5ICE9PSAnY3JvcCcpIHJldHVybjtcblxuICAgICAgLy8gYWN0aW9ucyBpbiBuZXh0IHdyaXRlIG9wZXJhdGlvblxuICAgICAgcm9vdC5yZWYuc2hvdWxkUmVzY2FsZSA9IHRydWU7XG4gICAgfTtcblxuICAgIGNvbnN0IGRpZENhbGN1bGF0ZVByZXZpZXdTaXplID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgIC8vIHJlbWVtYmVyIGRpbWVuc2lvbnNcbiAgICAgIHJvb3QucmVmLmltYWdlV2lkdGggPSBhY3Rpb24ud2lkdGg7XG4gICAgICByb290LnJlZi5pbWFnZUhlaWdodCA9IGFjdGlvbi5oZWlnaHQ7XG5cbiAgICAgIC8vIGFjdGlvbnMgaW4gbmV4dCB3cml0ZSBvcGVyYXRpb25cbiAgICAgIHJvb3QucmVmLnNob3VsZFJlc2NhbGUgPSB0cnVlO1xuICAgICAgcm9vdC5yZWYuc2hvdWxkRHJhd1ByZXZpZXcgPSB0cnVlO1xuXG4gICAgICAvLyBhcyBpbWFnZSBsb2FkIGNvdWxkIHRha2UgYSB3aGlsZSBhbmQgZmlyZSB3aGVuIGRyYXcgbG9vcCBpcyByZXN0aW5nIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIGtpY2tcbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0tJQ0snKTtcbiAgICB9O1xuXG4gICAgLy8gc3RhcnQgd3JpdGluZ1xuICAgIHZpZXcucmVnaXN0ZXJXcml0ZXIoXG4gICAgICBjcmVhdGVSb3V0ZShcbiAgICAgICAge1xuICAgICAgICAgIERJRF9SRVNJWkVfUk9PVDogZGlkUmVzaXplVmlldyxcbiAgICAgICAgICBESURfU1RPUF9SRVNJWkU6IGRpZFJlc2l6ZVZpZXcsXG4gICAgICAgICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW0sXG4gICAgICAgICAgRElEX0lNQUdFX1BSRVZJRVdfQ0FMQ1VMQVRFX1NJWkU6IGRpZENhbGN1bGF0ZVByZXZpZXdTaXplLFxuICAgICAgICAgIERJRF9VUERBVEVfSVRFTV9NRVRBREFUQTogZGlkVXBkYXRlSXRlbU1ldGFkYXRhXG4gICAgICAgIH0sXG4gICAgICAgICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAgICAgICAvLyBubyBwcmV2aWV3IHZpZXcgYXR0YWNoZWRcbiAgICAgICAgICBpZiAoIXJvb3QucmVmLmltYWdlUHJldmlldykgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgd2hpbGUgaGlkZGVuXG4gICAgICAgICAgaWYgKHJvb3QucmVjdC5lbGVtZW50LmhpZGRlbikgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gcmVzaXplIHRoZSBpdGVtIHBhbmVsXG4gICAgICAgICAgaWYgKHJvb3QucmVmLnNob3VsZFJlc2NhbGUpIHtcbiAgICAgICAgICAgIHJlc2NhbGVJdGVtKHJvb3QsIHByb3BzKTtcbiAgICAgICAgICAgIHJvb3QucmVmLnNob3VsZFJlc2NhbGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm9vdC5yZWYuc2hvdWxkRHJhd1ByZXZpZXcpIHtcbiAgICAgICAgICAgIC8vIHF1ZXVlIHRpbGwgbmV4dCBmcmFtZSBzbyB3ZSdyZSBzdXJlIHRoZSBoZWlnaHQgaGFzIGJlZW4gYXBwbGllZCB0aGlzIGZvcmNlcyB0aGUgZHJhdyBpbWFnZSBjYWxsIGluc2lkZSB0aGUgd3JhcHBlciB2aWV3IHRvIHVzZSB0aGUgY29ycmVjdCBoZWlnaHRcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG5lc3RpbmcgaXMgaG9ycmlibGUgYnV0IGl0IGZpeGVzIGFuIGlzc3VlIHdpdGggMTAwaHogZGlzcGxheXMgb24gQ2hyb21lXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcWluYS9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy9pc3N1ZXMvNTdcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRklOSVNIX0NBTENVTEFURV9QUkVWSUVXU0laRScsIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBwcm9wcy5pZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByb290LnJlZi5zaG91bGREcmF3UHJldmlldyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0pO1xuXG4gIC8vIGV4cG9zZSBwbHVnaW5cbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBpbWFnZSBwcmV2aWV3XG4gICAgICBhbGxvd0ltYWdlUHJldmlldzogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgIC8vIGZpbHRlcnMgZmlsZSBpdGVtcyB0byBkZXRlcm1pbmUgd2hpY2ggYXJlIHNob3duIGFzIHByZXZpZXdcbiAgICAgIGltYWdlUHJldmlld0ZpbHRlckl0ZW06IFsoKSA9PiB0cnVlLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgICAgLy8gRml4ZWQgcHJldmlldyBoZWlnaHRcbiAgICAgIGltYWdlUHJldmlld0hlaWdodDogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgLy8gTWluIGltYWdlIGhlaWdodFxuICAgICAgaW1hZ2VQcmV2aWV3TWluSGVpZ2h0OiBbNDQsIFR5cGUuSU5UXSxcblxuICAgICAgLy8gTWF4IGltYWdlIGhlaWdodFxuICAgICAgaW1hZ2VQcmV2aWV3TWF4SGVpZ2h0OiBbMjU2LCBUeXBlLklOVF0sXG5cbiAgICAgIC8vIE1heCBzaXplIG9mIHByZXZpZXcgZmlsZSBmb3Igd2hlbiBjcmVhdGVJbWFnZUJpdG1hcCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICBpbWFnZVByZXZpZXdNYXhGaWxlU2l6ZTogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgLy8gVGhlIGFtb3VudCBvZiBleHRyYSBwaXhlbHMgYWRkZWQgdG8gdGhlIGltYWdlIHByZXZpZXcgdG8gYWxsb3cgY29tZm9ydGFibGUgem9vbWluZ1xuICAgICAgaW1hZ2VQcmV2aWV3Wm9vbUZhY3RvcjogWzIsIFR5cGUuSU5UXSxcblxuICAgICAgLy8gU2hvdWxkIHdlIHVwc2NhbGUgc21hbGwgaW1hZ2VzIHRvIGZpdCB0aGUgbWF4IGJvdW5kaW5nIGJveCBvZiB0aGUgcHJldmlldyBhcmVhXG4gICAgICBpbWFnZVByZXZpZXdVcHNjYWxlOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgIC8vIE1heCBzaXplIG9mIHByZXZpZXcgZmlsZSB0aGF0IHdlIGFsbG93IHRvIHRyeSB0byBpbnN0YW50IHByZXZpZXcgaWYgY3JlYXRlSW1hZ2VCaXRtYXAgaXMgbm90IHN1cHBvcnRlZCwgZWxzZSBpbWFnZSBpcyBxdWV1ZWQgZm9yIGxvYWRpbmdcbiAgICAgIGltYWdlUHJldmlld01heEluc3RhbnRQcmV2aWV3RmlsZVNpemU6IFsxMDAwMDAwLCBUeXBlLklOVF0sXG5cbiAgICAgIC8vIFN0eWxlIG9mIHRoZSB0cmFuc3BhcmFuY3kgaW5kaWNhdG9yIHVzZWQgYmVoaW5kIGltYWdlc1xuICAgICAgaW1hZ2VQcmV2aWV3VHJhbnNwYXJlbmN5SW5kaWNhdG9yOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgICAvLyBFbmFibGVzIG9yIGRpc2FibGVzIHJlYWRpbmcgYXZlcmFnZSBpbWFnZSBjb2xvclxuICAgICAgaW1hZ2VQcmV2aWV3Q2FsY3VsYXRlQXZlcmFnZUltYWdlQ29sb3I6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgLy8gRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgcHJldmlld2luZyBvZiBtYXJrdXBcbiAgICAgIGltYWdlUHJldmlld01hcmt1cFNob3c6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAvLyBBbGxvd3MgZmlsdGVyaW5nIG9mIG1hcmt1cCB0byBvbmx5IHNob3cgY2VydGFpbiBzaGFwZXNcbiAgICAgIGltYWdlUHJldmlld01hcmt1cEZpbHRlcjogWygpID0+IHRydWUsIFR5cGUuRlVOQ1RJT05dXG4gICAgfVxuICB9O1xufTtcblxuLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbmNvbnN0IGlzQnJvd3NlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuaWYgKGlzQnJvd3Nlcikge1xuICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwbHVnaW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css":
/*!*******************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"dfa5576fce00\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTklLSElMXFxPbmVEcml2ZVxcRGVza1xcbGVhcm5pbmdfbWFuYWdlbWVudFxcY2xpZW50XFxub2RlX21vZHVsZXNcXGZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3XFxkaXN0XFxmaWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkZmE1NTc2ZmNlMDBcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\n");

/***/ })

};
;